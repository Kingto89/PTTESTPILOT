<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>PT Lab ‚Äî Goniometry Trainer</title>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<style>
  html,body{margin:0;height:100%;background:#0b1220;color:#e5e7eb;overflow:hidden;font-family:system-ui,Segoe UI,Roboto}
  canvas{width:100%;height:100%;display:block}
  .panel{
    position:fixed;left:0;top:0;bottom:0;width:320px;background:#0f172a;
    border-right:1px solid #1f2937;padding:14px;overflow:auto;z-index:20
  }
  h3{margin:8px 0 12px 0}
  label{display:block;font-size:13px;margin-top:10px;color:#cbd5e1}
  select,button,input[type=range]{
    width:100%;margin:6px 0 8px 0;padding:8px 10px;border-radius:10px;
    background:#1e293b;border:1px solid #334155;color:#e2e8f0
  }
  .row{display:flex;gap:8px}
  .row>button{flex:1}
  .hud{
    position:fixed;top:10px;left:50%;transform:translateX(-50%);
    background:rgba(15,23,42,.75);border:1px solid #334155;border-radius:10px;
    padding:6px 10px;font-weight:700;backdrop-filter:blur(6px);z-index:15
  }
  .toast{
    position:fixed;bottom:10px;left:50%;transform:translateX(-50%);
    background:rgba(2,6,23,.7);border:1px solid #334155;border-radius:10px;
    padding:6px 10px;font-size:13px;display:none;z-index:15
  }
  #msg{position:fixed;top:10px;left:10px;background:rgba(15,23,42,.7);
       border:1px solid #334155;border-radius:8px;padding:6px 10px;font-size:13px;z-index:15}
  #log{background:#0b1220;border:1px solid #1f2937;height:130px;overflow:auto;border-radius:8px;padding:8px}

  .legend{font-size:12px;color:#cbd5e1;margin-top:6px}
  .chip{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid #334155;background:#0b1220;margin-right:6px}

  /* ===== Passive SVG goniometer overlay ===== */
  #gonioHost{position:fixed;inset:0;z-index:12;pointer-events:none}
  #gonioHost svg{width:100vw;height:100vh;background:transparent;pointer-events:none}
  .tick{stroke:#64748b;stroke-width:.9}
  .tickBig{stroke-width:1.6}
  .armA{stroke:#ef4444;fill:none}
  .armB{stroke:#22c55e;fill:none}
  .axisA{stroke:#ef4444;stroke-width:1.6;opacity:.85}
  .axisB{stroke:#22c55e;stroke-width:1.6;opacity:.85}
  .rulerTick{stroke:#94a3b8}
  .labelOuter{fill:#e5e7eb;font-size:11px;text-anchor:middle;dominant-baseline:middle;paint-order:stroke;stroke:#0b1220;stroke-width:3px}
  .labelInner{fill:#fca5a5;font-size:8.2px;text-anchor:middle;dominant-baseline:middle;paint-order:stroke;stroke:#0b1220;stroke-width:3px}
  .ruLbl{fill:#cbd5e1;font-size:9.5px;dominant-baseline:middle;paint-order:stroke;stroke:#0b1220;stroke-width:3px}

  .hide{display:none}
</style>
</head>
<body>
  <div class="panel">
    <h3>Goniometry Trainer</h3>

    <label>Measurement Preset</label>
    <select id="preset">
      <option value="cerv_flex">Cervical Flexion</option>
      <option value="cerv_rot" selected>Cervical Rotation</option>
      <option value="cerv_lat">Cervical Lateral Bending</option>
    </select>

    <div class="row">
      <button id="pickFulcrum">1Ô∏è‚É£ Fulcrum</button>
      <button id="pickStationary">2Ô∏è‚É£ Stationary</button>
      <button id="pickMoving">3Ô∏è‚É£ Moving</button>
    </div>

    <label>Tolerance (cm)</label>
    <input type="range" min="0.5" max="5" step="0.5" value="2" id="tol">
    <div class="legend">Green ‚â§ tolerance ‚Ä¢ Red > tolerance</div>

    <label>Options</label>
    <div class="row">
      <button id="toggleGhost">üëª Ghost Landmarks</button>
      <button id="resetAll">Reset</button>
    </div>

    <div class="row">
      <button id="measureToggle">üß≠ Measure: OFF</button>
    </div>

    <div class="legend">
      <span class="chip" style="border-color:#60a5fa">Stationary arm</span>
      <span class="chip" style="border-color:#f472b6">Moving arm</span>
    </div>

    <label>Event Log</label>
    <pre id="log"></pre>
  </div>

  <!-- Goniometer overlay -->
  <div id="gonioHost" class="hide" aria-hidden="true">
    <svg id="gonioSvg" aria-label="Universal goniometer">
      <g id="viewport" transform="translate(0,0) scale(1)">
        <g id="rotWrap" transform="rotate(0)">
          <g id="mirrorWrap" transform="scale(1,1)">
            <g id="instrument">
              <g id="head">
                <circle r="120" fill="#0f172a" stroke="#94a3b8" stroke-width="1.6"/>
                <circle r="86"  fill="none" stroke="#94a3b8" stroke-width="0.9" opacity="0.65"/>
                <g id="ticks"></g>
                <g id="labelsFixed">
                  <g id="numsOut"></g>
                  <g id="numsInWrap"><g id="numsIn"></g></g>
                </g>
                <circle r="3.2" fill="#94a3b8"/>
              </g>

              <!-- RED stationary arm -->
              <g id="armA_grp">
                <rect class="armA" x="-10" y="120" width="20" height="260" rx="10" stroke-width="3"/>
                <line id="axisA" class="axisA" x1="0" y1="380" x2="0" y2="-116" stroke-linecap="round"/>
                <g id="armA_ruler"></g>
                <circle id="armA_knob" cx="0" cy="380" r="10" fill="#ef4444"/>
              </g>

              <!-- GREEN moving arm -->
              <g id="armB_grp">
                <rect class="armB" x="-10" y="-380" width="20" height="500" rx="10" stroke-width="3"/>
                <line id="axisB" class="axisB" x1="0" y1="-380" x2="0" y2="124" stroke-linecap="round"/>
                <g id="armB_ruler"></g>
                <circle id="armB_knob" cx="0" cy="-380" r="10" fill="#22c55e"/>
              </g>
            </g>
          </g>
        </g>
      </g>
    </svg>
  </div>

  <div id="msg">Loading model‚Ä¶</div>
  <div class="hud" id="hud">Angle: 0¬∞</div>
  <div class="toast" id="toast">Preset updated</div>
  <canvas id="c"></canvas>

<script type="module">
  import * as THREE from "three";
  import { OrbitControls } from "three/addons/controls/OrbitControls.js";
  import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
  import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";
  import { KTX2Loader } from "three/addons/loaders/KTX2Loader.js";
  import { MeshoptDecoder } from "three/addons/libs/meshopt_decoder.module.js";

  /* ===== SVG goniometer (passive overlay) ===== */
  let Gonio = { show:()=>{}, hide:()=>{}, setPose:()=>{}, degFromScreenVec:()=>0 };
  try {
    Gonio = (() => {
      const host  = document.getElementById('gonioHost');
      const svg   = document.getElementById('gonioSvg');
      const viewport   = document.getElementById('viewport');
      const rotWrap    = document.getElementById('rotWrap');
      const mirrorWrap = document.getElementById('mirrorWrap');
      const ticks = document.getElementById('ticks');
      const numsOut = document.getElementById('numsOut');
      const numsInWrap = document.getElementById('numsInWrap');
      const numsIn = document.getElementById('numsIn');
      const armA_grp = document.getElementById('armA_grp');
      const armB_grp = document.getElementById('armB_grp');
      const armA_ruler = document.getElementById('armA_ruler');
      const armB_ruler = document.getElementById('armB_ruler');

      const R=120, Rin=86;
      const clamp360 = a => (a%360+360)%360;
      const toDegUp  = (x,y)=> clamp360(Math.atan2(-y,x)*180/Math.PI + 90); // 0¬∞ = up

      function line(parent,x1,y1,x2,y2,cls){
        const n=document.createElementNS('http://www.w3.org/2000/svg','line');
        n.setAttribute('x1',x1); n.setAttribute('y1',y1);
        n.setAttribute('x2',x2); n.setAttribute('y2',y2);
        if (cls) n.setAttribute('class',cls); parent.appendChild(n);
      }
      function text(parent,x,y,str,cls,rot){
        const n=document.createElementNS('http://www.w3.org/2000/svg','text');
        n.setAttribute('x',x); n.setAttribute('y',y);
        n.setAttribute('class',cls||'labelOuter');
        if (rot) n.setAttribute('transform',`rotate(${rot} ${x} ${y})`);
        n.textContent=str; parent.appendChild(n); return n;
      }

      // Build ticks/labels once
      (function build(){
        for(let d=0; d<360; d+=5){
          const a=(d-90)*Math.PI/180, big=d%30===0, len=big?12:6;
          line(ticks, Math.cos(a)*(R-len), Math.sin(a)*(R-len), Math.cos(a)*R, Math.sin(a)*R, big?'tick tickBig':'tick');
        }
        // OUTER labels 0/20/40/60/80 near 90¬∞ & 270¬∞
        const rWhite = R - 8;
        for (let d = 0; d < 360; d += 10) {
          const diff90  = Math.abs(((d - 90)  % 360 + 540) % 360 - 180);
          const diff270 = Math.abs(((d - 270) % 360 + 540) % 360 - 180);
          const val = Math.min(diff90, diff270);
          if (val % 20 === 0 && val <= 80) {
            const a=(d-90)*Math.PI/180, x=Math.cos(a)*rWhite, y=Math.sin(a)*rWhite;
            text(numsOut, x, y, String(val), 'labelOuter');
          }
        }
        // INNER 0‚Äì180‚Äì0 each 10¬∞, single centered 0 at the neck
        const rInnerText = Rin + 9;
        const valFromTheta = th => { const t=(th+180)%360; return t<=180? t : 360-t; };
        for(let th=0; th<360; th+=10){
          const val = valFromTheta(th);
          if (val % 10 !== 0) continue;
          if (val===0 && th!==180) continue;
          const a=(th-90)*Math.PI/180, x=Math.cos(a)*rInnerText, y=Math.sin(a)*rInnerText;
          text(numsIn, x, y, String(val), 'labelInner');
        }
        buildTipRuler(armA_ruler,  380, +1, 'A');
        buildTipRuler(armB_ruler, -380, -1, 'B');
      })();

      function buildTipRuler(group, tipY, dir, which){
        group.innerHTML='';
        const CM_TO_PX = 14, IN_TO_CM = 2.5;
        const cmMax=15, inMax=6;
        for(let cm=0; cm<=cmMax+1e-6; cm+=0.5){
          const y = tipY - dir*(cm*CM_TO_PX);
          const long = Math.abs(cm - Math.round(cm)) < 1e-6;
          const mid  = !long && Math.abs(cm*2 - Math.round(cm*2)) < 1e-6;
          const w = long?8:mid?5:3;
          line(group, -10, y, -10-w, y, 'rulerTick');
          if (long){ const t=text(group,-18,y,Math.round(cm),'ruLbl',-90); t.dataset.arm=which; t.dataset.x=-18; t.dataset.y=y; }
        }
        for(let inch=0; inch<=inMax+1e-6; inch+=0.5){
          const y = tipY - dir*(inch*IN_TO_CM*CM_TO_PX);
          const long = Math.abs(inch - Math.round(inch)) < 1e-6;
          const mid  = !long && Math.abs(inch*2 - Math.round(inch*2)) < 1e-6;
          const w = long?8:mid?5:3;
          line(group, 10, y, 10+w, y, 'rulerTick');
          if (long){ const t=text(group,18,y,Math.round(inch),'ruLbl',90); t.dataset.arm=which; t.dataset.x=18; t.dataset.y=y; }
        }
        const tcm=text(group,-26,tipY,'cm','ruLbl',-90); tcm.dataset.arm=which; tcm.dataset.x=-26; tcm.dataset.y=tipY;
        const tin=text(group, 26,tipY,'in','ruLbl', 90); tin.dataset.arm=which; tcm.dataset.x= 26; tin.dataset.y=tipY;
      }

      // state and render
      let mov=0, gRot=0, panX=0, panY=0, zoom=1, mirrored=false;
      function applyView(){ viewport.setAttribute('transform', `translate(${panX},${panY}) scale(${zoom})`); }
      function applyRot(){ rotWrap.setAttribute('transform', `rotate(${gRot})`); }
      function applyLabelFix(){
        const sx = mirrored ? -1 : 1;
        document.getElementById('labelsFixed').setAttribute('transform', `scale(${sx},1) rotate(${-gRot})`);
        numsInWrap.setAttribute('transform', `rotate(${sx * gRot})`);
      }
      function render(){
        armA_grp.setAttribute('transform', `rotate(0)`);
        armB_grp.setAttribute('transform', `rotate(${mov})`);
        document.querySelectorAll('.ruLbl').forEach(t=>{
          const which=t.dataset.arm; const base = (which==='A'? 0 : mov) + gRot;
          const x=+t.dataset.x, y=+t.dataset.y;
          t.setAttribute('transform', `rotate(${-base} ${x} ${y})`);
        });
      }
      applyView(); applyRot(); applyLabelFix(); render();

      function show(){ host.classList.remove('hide'); host.setAttribute('aria-hidden','false'); }
      function hide(){ host.classList.add('hide'); host.setAttribute('aria-hidden','true'); }
      // center at screen (cx,cy); red arm = baseDeg; green arm = movDeg
      function setPose(cx, cy, baseDeg, movDeg){
        panX = cx; panY = cy; zoom = 1;
        gRot = baseDeg;
        mov  = ((movDeg - baseDeg)%360 + 360)%360;
        applyView(); applyRot(); applyLabelFix(); render();
      }
      function degFromScreenVec(dx,dy){ return toDegUp(dx,dy); }

      return { show, hide, setPose, degFromScreenVec };
    })();
  } catch(e){
    console.warn("Goniometer overlay disabled:", e);
  }

  // ===== UI refs =====
  const msg = document.getElementById("msg");
  const hud = document.getElementById("hud");
  const logEl = document.getElementById("log");
  const toast = document.getElementById("toast");
  const tolEl = document.getElementById("tol");
  let tol = parseFloat(tolEl.value);
  tolEl.oninput = () => (tol = parseFloat(tolEl.value));

  // ===== Three.js =====
  const canvas = document.getElementById("c");
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setPixelRatio(devicePixelRatio);
  renderer.setSize(innerWidth, innerHeight);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b1220);

  const camera = new THREE.PerspectiveCamera(45, innerWidth / innerHeight, 0.1, 100);
  camera.position.set(0.8, 1.6, 2.5);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  scene.add(new THREE.HemisphereLight(0xffffff, 0x333344, 1.2));
  const dl = new THREE.DirectionalLight(0xffffff, 1);
  dl.position.set(3, 4, 2);
  scene.add(dl);

  // ===== Floor protractor (kept) =====
  const protractor = new THREE.Group(); scene.add(protractor);
  const radius = 1.8;
  const tickMat = new THREE.LineBasicMaterial({ color: 0x475569 });
  for (let d = 0; d < 360; d += 10) {
    const a = THREE.MathUtils.degToRad(d);
    const r1 = radius * 0.95, r2 = (d % 30 === 0) ? radius * 0.88 : radius * 0.93;
    const pts = [
      new THREE.Vector3(Math.cos(a) * r1, 0, Math.sin(a) * r1),
      new THREE.Vector3(Math.cos(a) * r2, 0, Math.sin(a) * r2)
    ];
    protractor.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), tickMat));
  }
  const makeLabel = (text) => {
    const div = document.createElement('div');
    div.textContent = text;
    div.style.position = 'fixed';
    div.style.color = '#94a3b8';
    div.style.font = '12px system-ui';
    div.style.pointerEvents = 'none';
    div.style.zIndex = 10;
    document.body.appendChild(div);
    return div;
  };
  const labels = []; for (let d = 0; d < 360; d += 30) labels.push({deg:d, el:makeLabel(`${d}¬∞`)});
  const tmpV = new THREE.Vector3();
  function layoutLabels() {
    labels.forEach(({deg, el})=>{
      const a = THREE.MathUtils.degToRad(deg);
      tmpV.set(Math.cos(a) * radius, 0, Math.sin(a) * radius).applyMatrix4(protractor.matrixWorld);
      tmpV.project(camera);
      const x = (tmpV.x * 0.5 + 0.5) * innerWidth;
      const y = (-tmpV.y * 0.5 + 0.5) * innerHeight;
      el.style.left = `${x - 10}px`;
      el.style.top  = `${y - 8}px`;
    });
  }

  // ===== Model loader =====
  const loader = new GLTFLoader();
  loader.setMeshoptDecoder(MeshoptDecoder);
  const draco = new DRACOLoader();
  draco.setDecoderPath("https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/");
  loader.setDRACOLoader(draco);
  const ktx2 = new KTX2Loader();
  ktx2.setTranscoderPath("https://unpkg.com/three@0.160.0/examples/jsm/libs/basis/");
  ktx2.detectSupport(renderer);
  loader.setKTX2Loader(ktx2);

  let model = null;
  const MODEL_URL = "./Athletic_Grace_1006002620_texture.glb"; // same folder as index.html

  loader.load(MODEL_URL, (gltf) => {
    model = gltf.scene; scene.add(model);

    const box = new THREE.Box3().setFromObject(model);
    const c = box.getCenter(new THREE.Vector3());
    model.position.sub(new THREE.Vector3(c.x, 0, c.z)); // keep Y

    // Align floor protractor to model anterior
    const forward = new THREE.Vector3(0,0,1).applyQuaternion(model.quaternion);
    const yaw = Math.atan2(forward.z, forward.x);
    protractor.rotation.y = yaw;

    msg.textContent = "‚úÖ Model loaded";
  }, (xhr) => {
    msg.textContent = xhr.lengthComputable ? `Loading ${Math.round((xhr.loaded/xhr.total)*100)}%` : "Loading‚Ä¶";
  }, (err) => {
    console.error(err); msg.textContent = "‚ùå Failed to load model (check file name/path)";
  });

  // ===== Landmarks =====
  const matGood = new THREE.MeshBasicMaterial({ color: 0x22c55e });
  const matBad  = new THREE.MeshBasicMaterial({ color: 0xef4444 });
  const dot = () => new THREE.Mesh(new THREE.SphereGeometry(0.01, 16, 16), matBad.clone());

  const user = { fulcrum: dot(), stationary: dot(), moving: dot() };
  Object.values(user).forEach(m => { m.visible = false; scene.add(m); });

  const userLocal = { fulcrum:null, stationary:null, moving:null };

  const ghost = { fulcrum: dot(), stationary: dot(), moving: dot() };
  Object.values(ghost).forEach(m => { m.material = new THREE.MeshBasicMaterial({ color: 0x38bdf8 });
                                      m.visible = false; scene.add(m); });

  const PRESETS = {
    cerv_flex: {
      fulcrum:   new THREE.Vector3(0.08, 1.65, 0.02),
      stationary:new THREE.Vector3(0.12, 1.55, 0.15),
      moving:    new THREE.Vector3(0.10, 1.68, 0.12)
    },
    cerv_rot: {
      fulcrum:   new THREE.Vector3(0.08, 1.80, 0.02),
      stationary:new THREE.Vector3(0.18, 1.55, 0.15),
      moving:    new THREE.Vector3(0.10, 1.70, 0.20)
    },
    cerv_lat: {
      fulcrum:   new THREE.Vector3(0.05, 1.55, 0.02),
      stationary:new THREE.Vector3(0.00, 1.45, 0.10),
      moving:    new THREE.Vector3(0.10, 1.60, 0.02)
    }
  };
  let truth = { ...PRESETS.cerv_rot };

  let ghostOn = false;
  function updateGhost() {
    ghost.fulcrum.position.copy(truth.fulcrum);
    ghost.stationary.position.copy(truth.stationary);
    ghost.moving.position.copy(truth.moving);
    Object.values(ghost).forEach(m => { m.visible = ghostOn; });
  }

  // ===== Picking & placement =====
  let target = null;
  const ray = new THREE.Raycaster();
  const mouse = new THREE.Vector2();

  // track ‚Äúbuttons clicked‚Äù vs ‚Äúpoints placed‚Äù
  const clicked = { fulcrum:false, stationary:false, moving:false };
  const placed  = { fulcrum:false, stationary:false, moving:false };

  function maybeShowGoniometerOnClicks(){
    if (clicked.fulcrum && clicked.stationary && clicked.moving) {
      // show centered preview immediately (like old popup)
      const cx = innerWidth/2, cy = innerHeight/2;
      Gonio.show();
      Gonio.setPose(cx, cy, 0, 45); // neutral preview; real pose will override once points are placed
    }
  }

  function log(t) {
    logEl.textContent += t + "\n";
    logEl.scrollTop = logEl.scrollHeight;
  }

  function toScreen(v3){
    const v = v3.clone().project(camera);
    return { x:(v.x*0.5+0.5)*innerWidth, y:(-v.y*0.5+0.5)*innerHeight };
  }

  function placePoint(name, worldPoint) {
    if (!model) return;
    const local = model.worldToLocal(worldPoint.clone());
    userLocal[name] = local;
    user[name].visible = true;
    user[name].position.copy(worldPoint);
    placed[name] = true;

    const cm = worldPoint.distanceTo(truth[name]) * 100.0;
    user[name].material.color.set(cm <= tol ? 0x22c55e : 0xef4444);
    log(`${name}: ${cm.toFixed(1)} cm`);

    updateFromLocals();
  }

  canvas.addEventListener("pointerdown", (e) => {
    if (!target || !model) return;
    const r = canvas.getBoundingClientRect();
    mouse.x = ((e.clientX - r.left) / r.width) * 2 - 1;
    mouse.y = -((e.clientY - r.top) / r.height) * 2 + 1;
    ray.setFromCamera(mouse, camera);
    const hits = ray.intersectObjects(scene.children, true)
      .filter(h => !(h.object instanceof THREE.Line) && h.object !== protractor);
    if (!hits.length) return;
    placePoint(target, hits[0].point);
    target = null;
  });

  // ===== Helper lines (3D) =====
  const line1 = new THREE.Line(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0x60a5fa }));
  const line2 = new THREE.Line(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0xf472b6 }));
  scene.add(line1, line2);

  function setAngle(a) { hud.textContent = `Angle: ${a.toFixed(0)}¬∞`; }

  function updateFromLocals() {
    if (!model) return;
    ["fulcrum","stationary","moving"].forEach(k=>{
      if (userLocal[k]) {
        user[k].position.copy(userLocal[k].clone()).applyMatrix4(model.matrixWorld);
        user[k].visible = true;
      }
    });

    const f = user.fulcrum.visible ? user.fulcrum.position : null;
    const s = user.stationary.visible ? user.stationary.position : null;
    const m = user.moving.visible ? user.moving.position : null;

    line1.visible = !!(f && s);
    line2.visible = !!(f && m);
    if (line1.visible){ line1.geometry.dispose(); line1.geometry = new THREE.BufferGeometry().setFromPoints([f, s]); }
    if (line2.visible){ line2.geometry.dispose(); line2.geometry = new THREE.BufferGeometry().setFromPoints([f, m]); }

    if (f && s && m) {
      const vs = s.clone().sub(f).normalize();
      const vm = m.clone().sub(f).normalize();
      const ang = THREE.MathUtils.radToDeg(Math.acos(THREE.MathUtils.clamp(vs.dot(vm), -1, 1)));
      setAngle(ang);

      // Drive overlay to real pose
      const Fs = toScreen(f), Ss = toScreen(s), Ms = toScreen(m);
      const baseDeg = Gonio.degFromScreenVec(Ss.x - Fs.x, Ss.y - Fs.y); // Stationary (RED)
      const movDeg  = Gonio.degFromScreenVec(Ms.x - Fs.x, Ms.y - Fs.y); // Moving (GREEN)
      Gonio.show();
      Gonio.setPose(Fs.x, Fs.y, baseDeg, movDeg);
    } else {
      setAngle(0);
      // Keep preview if shown by button-click rule; otherwise hide
      if (!(clicked.fulcrum && clicked.stationary && clicked.moving)) Gonio.hide();
    }
  }

  // ===== Buttons & presets =====
  const pickFulcrum = document.getElementById("pickFulcrum");
  const pickStationary = document.getElementById("pickStationary");
  const pickMoving = document.getElementById("pickMoving");
  const toggleGhostBtn = document.getElementById("toggleGhost");
  const resetAll = document.getElementById("resetAll");
  const presetSel = document.getElementById("preset");
  const measureToggle = document.getElementById("measureToggle");

  let followMeasure = false;

  pickFulcrum.onclick   = () => { clicked.fulcrum=true;   target = "fulcrum";   log("Place Fulcrum");   maybeShowGoniometerOnClicks(); };
  pickStationary.onclick= () => { clicked.stationary=true;target = "stationary";log("Place Stationary"); maybeShowGoniometerOnClicks(); };
  pickMoving.onclick    = () => { clicked.moving=true;    target = "moving";    log("Place Moving");    maybeShowGoniometerOnClicks(); };

  toggleGhostBtn.onclick = () => {
    ghostOn = !ghostOn; updateGhost();
    toast.textContent = ghostOn ? "Ghost landmarks ON" : "Ghost landmarks OFF";
    showToast();
  };

  resetAll.onclick = () => {
    Object.values(user).forEach(m => m.visible = false);
    userLocal.fulcrum = userLocal.stationary = userLocal.moving = null;
    Object.keys(placed).forEach(k=> placed[k]=false);
    Object.keys(clicked).forEach(k=> clicked[k]=false);
    line1.visible = line2.visible = false;
    setAngle(0);
    Gonio.hide();
    log("Reset");
  };

  presetSel.onchange = () => {
    const p = presetSel.value;
    truth = { ...PRESETS[p] };
    updateGhost();
    toast.textContent = `Preset: ${presetSel.options[presetSel.selectedIndex].text}`;
    showToast();
  };

  measureToggle.onclick = () => {
    followMeasure = !followMeasure;
    measureToggle.textContent = followMeasure ? "üß≠ Measure: ON" : "üß≠ Measure: OFF";
  };

  function showToast() {
    toast.style.display = 'block';
    clearTimeout(showToast.tid);
    showToast.tid = setTimeout(()=> toast.style.display='none', 1200);
  }

  // layout + render
  addEventListener("resize", () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
    layoutLabels();
    updateFromLocals();
  });

  const clock = new THREE.Clock();
  (function animate() {
    clock.getDelta();
    controls.update();
    if (followMeasure) updateFromLocals(); // follow rig if enabled
    renderer.render(scene, camera);
    layoutLabels();
    requestAnimationFrame(animate);
  })();
</script>
</body>
</html>
