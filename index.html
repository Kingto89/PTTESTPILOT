<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>PT Lab ‚Äî Goniometry Trainer (True Align + Follow)</title>

<!-- Import map so we can use "three" bare specifiers on GitHub Pages -->
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<style>
  html,body{margin:0;height:100%;background:#0b1220;color:#e5e7eb;overflow:hidden;font-family:system-ui, Segoe UI, Roboto}
  canvas{width:100%;height:100%;display:block}
  .panel{
    position:fixed;left:0;top:0;bottom:0;width:320px;background:#0f172a;
    border-right:1px solid #1f2937;padding:14px;overflow:auto;z-index:20
  }
  h3{margin:8px 0 12px 0}
  label{display:block;font-size:13px;margin-top:10px;color:#cbd5e1}
  select,button,input[type=range]{
    width:100%;margin:6px 0 8px 0;padding:8px 10px;border-radius:10px;
    background:#1e293b;border:1px solid #334155;color:#e2e8f0
  }
  .row{display:flex;gap:8px}
  .row>button{flex:1}
  .hud{
    position:fixed;top:10px;left:50%;transform:translateX(-50%);
    background:rgba(15,23,42,.75);border:1px solid #334155;border-radius:10px;
    padding:6px 10px;font-weight:700;backdrop-filter:blur(6px);z-index:15
  }
  .toast{
    position:fixed;bottom:10px;left:50%;transform:translateX(-50%);
    background:rgba(2,6,23,.7);border:1px solid #334155;border-radius:10px;
    padding:6px 10px;font-size:13px;display:none;z-index:15
  }
  #log{background:#0b1220;border:1px solid #1f2937;height:130px;overflow:auto;border-radius:8px;padding:8px}
  #msg{position:fixed;top:10px;left:10px;color:#e5e7eb;background:rgba(15,23,42,.7);
       border:1px solid #334155;border-radius:8px;padding:6px 10px;font-size:13px;z-index:15}
  .legend{font-size:12px;color:#cbd5e1;margin-top:6px}
  .chip{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid #334155;background:#0b1220;margin-right:6px}
  /* ===== SVG goniometer overlay ===== */
  #gonioHost{
    position:fixed;left:0;top:0;right:0;bottom:0;
    pointer-events:none; /* let three.js interactions pass through unless using gestures on SVG */
    z-index:12 /* under HUD/panel, over canvas */
  }
  #gonioHost svg{width:100vw;height:100vh;background:transparent}
  /* (styles copied from the standalone SVG, trimmed to essentials) */
  .tick{stroke:#64748b;stroke-width:.9}
  .tickBig{stroke-width:1.6}
  .armA{stroke:#ef4444;fill:none}
  .armB{stroke:#22c55e;fill:none}
  .knobA{fill:#ef4444}
  .knobB{fill:#22c55e}
  .axisA{stroke:#ef4444;stroke-width:1.6;opacity:.85}
  .axisB{stroke:#22c55e;stroke-width:1.6;opacity:.85}
  .rulerTick{stroke:#94a3b8}
  .labelOuter{fill:#e5e7eb;font-size:11px;text-anchor:middle;dominant-baseline:middle;paint-order:stroke;stroke:#0b1220;stroke-width:3px}
  .labelInner{fill:#fca5a5;font-size:8.2px;text-anchor:middle;dominant-baseline:middle;paint-order:stroke;stroke:#0b1220;stroke-width:3px}
  .ruLbl{fill:#cbd5e1;font-size:9.5px;dominant-baseline:middle;paint-order:stroke;stroke:#0b1220;stroke-width:3px}
  .bar{position:fixed;top:0;left:0;right:0;display:flex;gap:12px;justify-content:center;align-items:center;padding:6px 10px;background:#0b1220cc;border-bottom:1px solid #1f2937;backdrop-filter:blur(6px);z-index:13;font-weight:700}
  .btn{background:#0f172a;border:1px solid #334155;color:#e5e7eb;border-radius:10px;padding:4px 8px;cursor:pointer}
  .hide{display:none}
</style>
</head>
<body>
<div class="panel">
  <h3>Goniometry Trainer</h3>

  <label>Measurement Preset</label>
  <select id="preset">
    <option value="cerv_flex">Cervical Flexion</option>
    <option value="cerv_rot" selected>Cervical Rotation</option>
    <option value="cerv_lat">Cervical Lateral Bending</option>
  </select>

  <div class="row">
    <button id="pickFulcrum">1Ô∏è‚É£ Fulcrum</button>
    <button id="pickStationary">2Ô∏è‚É£ Stationary</button>
    <button id="pickMoving">3Ô∏è‚É£ Moving</button>
  </div>

  <label>Tolerance (cm)</label>
  <input type="range" min="0.5" max="5" step="0.5" value="2" id="tol">
  <div class="legend">Green ‚â§ tolerance ‚Ä¢ Red > tolerance</div>

  <label>Options</label>
  <div class="row">
    <button id="toggleGhost">üëª Ghost Landmarks</button>
    <button id="resetAll">Reset</button>
  </div>

  <div class="row">
    <button id="measureToggle">üß≠ Measure: OFF</button>
  </div>

  <div class="legend">
    <span class="chip" style="border-color:#60a5fa">Stationary arm</span>
    <span class="chip" style="border-color:#f472b6">Moving arm</span>
  </div>

  <label>Event Log</label>
  <pre id="log"></pre>
</div>

<div class="bar hide" id="gonioBar">
  <div>Angle (0‚Äì180¬∞): <span id="goniA180">0¬∞</span></div>
  <button id="goniReset" class="btn">Reset goniometer</button>
  <span style="font-weight:600;opacity:.85">Pinch to zoom ‚Ä¢ 2-finger rotate ‚Ä¢ drag green arm</span>
</div>

<!-- SVG goniometer overlay (hidden until all 3 points placed) -->
<div id="gonioHost" class="hide" aria-hidden="true">
  <svg id="gonioSvg" aria-label="Universal goniometer" style="pointer-events:auto">
    <g id="viewport" transform="translate(0,0) scale(1)">
      <g id="rotWrap" transform="rotate(0)">
        <g id="mirrorWrap" transform="scale(1,1)">
          <g id="instrument">
            <g id="head">
              <circle r="120" fill="#0f172a" stroke="#94a3b8" stroke-width="1.6"/>
              <circle r="86"  fill="none" stroke="#94a3b8" stroke-width="0.9" opacity="0.65"/>
              <g id="ticks"></g>
              <g id="labelsFixed">
                <g id="numsOut"></g>
                <g id="numsInWrap"><g id="numsIn"></g></g>
              </g>
              <circle r="3.2" fill="#94a3b8"/>
            </g>

            <!-- RED stationary arm (non-draggable) -->
            <g id="armA_grp">
              <rect class="armA" x="-10" y="120" width="20" height="260" rx="10" stroke-width="3"/>
              <line id="axisA" class="axisA" x1="0" y1="380" x2="0" y2="-116" stroke-linecap="round"/>
              <g id="armA_ruler"></g>
              <circle id="armA_knob" cx="0" cy="380" r="10" class="knobA"/>
            </g>

            <!-- GREEN moving arm (draggable) -->
            <g id="armB_grp" class="handle">
              <rect class="armB" x="-10" y="-380" width="20" height="500" rx="10" stroke-width="3"/>
              <line id="axisB" class="axisB" x1="0" y1="-380" x2="0" y2="124" stroke-linecap="round"/>
              <g id="armB_ruler"></g>
              <circle id="armB_knob" cx="0" cy="-380" r="10" class="knobB"/>
            </g>
          </g>
        </g>
      </g>
    </g>
  </svg>
</div>

<div id="msg">Loading model‚Ä¶</div>
<div class="hud" id="hud">Angle: 0¬∞</div>
<div class="toast" id="toast">Preset updated</div>
<canvas id="c"></canvas>

<script type="module">
  import * as THREE from "three";
  import { OrbitControls } from "three/addons/controls/OrbitControls.js";
  import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
  import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";
  import { KTX2Loader } from "three/addons/loaders/KTX2Loader.js";
  import { MeshoptDecoder } from "three/addons/libs/meshopt_decoder.module.js";

  /* ==============================
     Small helper: SVG goniometer API
     ============================== */
  const Gonio = (() => {
    const host  = document.getElementById('gonioHost');
    const bar   = document.getElementById('gonioBar');
    const svg   = document.getElementById('gonioSvg');
    const a180  = document.getElementById('goniA180');
    const reset = document.getElementById('goniReset');

    const viewport   = document.getElementById('viewport');
    const rotWrap    = document.getElementById('rotWrap');
    const mirrorWrap = document.getElementById('mirrorWrap');
    const ticks = document.getElementById('ticks');
    const numsOut = document.getElementById('numsOut');
    const numsInWrap = document.getElementById('numsInWrap');
    const numsIn = document.getElementById('numsIn');
    const armA_grp = document.getElementById('armA_grp');
    const armB_grp = document.getElementById('armB_grp');
    const armA_ruler = document.getElementById('armA_ruler');
    const armB_ruler = document.getElementById('armB_ruler');

    const R=120, Rin=86;
    const clamp360 = a => (a%360+360)%360;
    const toDegUp  = (x,y)=> clamp360(Math.atan2(-y,x)*180/Math.PI + 90); // 0¬∞ = up

    function line(parent,x1,y1,x2,y2,cls){
      const n=document.createElementNS('http://www.w3.org/2000/svg','line');
      n.setAttribute('x1',x1); n.setAttribute('y1',y1);
      n.setAttribute('x2',x2); n.setAttribute('y2',y2);
      if (cls) n.setAttribute('class',cls); parent.appendChild(n);
    }
    function text(parent,x,y,str,cls,rot){
      const n=document.createElementNS('http://www.w3.org/2000/svg','text');
      n.setAttribute('x',x); n.setAttribute('y',y);
      n.setAttribute('class',cls||'labelOuter');
      if (rot) n.setAttribute('transform',`rotate(${rot} ${x} ${y})`);
      n.textContent=str; parent.appendChild(n); return n;
    }

    // one-time build
    (function build(){
      for(let d=0; d<360; d+=5){
        const a=(d-90)*Math.PI/180, big=d%30===0, len=big?12:6;
        line(ticks, Math.cos(a)*(R-len), Math.sin(a)*(R-len), Math.cos(a)*R, Math.sin(a)*R, big?'tick tickBig':'tick');
      }
      // OUTER 0/20/40/60/80 around 90¬∞ and 270¬∞
      const rWhite = R - 8;
      for (let d = 0; d < 360; d += 10) {
        const diff90  = Math.abs(((d - 90)  % 360 + 540) % 360 - 180);
        const diff270 = Math.abs(((d - 270) % 360 + 540) % 360 - 180);
        const val = Math.min(diff90, diff270);
        if (val % 20 === 0 && val <= 80) {
          const a=(d-90)*Math.PI/180, x=Math.cos(a)*rWhite, y=Math.sin(a)*rWhite;
          text(numsOut, x, y, String(val), 'labelOuter');
        }
      }
      // INNER 0‚Äì180‚Äì0 every 10¬∞, with single centered 0 between the red 10s
      const rInnerText = Rin + 9;
      const valFromTheta = th => { const t=(th+180)%360; return t<=180? t : 360-t; };
      for(let th=0; th<360; th+=10){
        const val = valFromTheta(th);
        if (val % 10 !== 0) continue;
        const a=(th-90)*Math.PI/180, x=Math.cos(a)*rInnerText, y=Math.sin(a)*rInnerText;
        // hide the duplicate 0 at top; add a single centered 0 at 180 below
        if (val===0 && th!==180) continue;
        text(numsIn, x, y, String(val), 'labelInner');
      }
      // tip rulers (labels auto-upright)
      buildTipRuler(armA_ruler,  380, +1, 'A');
      buildTipRuler(armB_ruler, -380, -1, 'B');
    })();

    function buildTipRuler(group, tipY, dir, which){
      group.innerHTML='';
      const CM_TO_PX = 14, IN_TO_CM = 2.5;
      const cmMax=15, inMax=6;
      for(let cm=0; cm<=cmMax+1e-6; cm+=0.5){
        const y = tipY - dir*(cm*CM_TO_PX);
        const long = Math.abs(cm - Math.round(cm)) < 1e-6;
        const mid  = !long && Math.abs(cm*2 - Math.round(cm*2)) < 1e-6;
        const w = long?8:mid?5:3;
        line(group, -10, y, -10-w, y, 'rulerTick');
        if (long){ const t=text(group,-18,y,Math.round(cm),'ruLbl',-90); t.dataset.arm=which; t.dataset.x=-18; t.dataset.y=y; }
      }
      for(let inch=0; inch<=inMax+1e-6; inch+=0.5){
        const y = tipY - dir*(inch*IN_TO_CM*14);
        const long = Math.abs(inch - Math.round(inch)) < 1e-6;
        const mid  = !long && Math.abs(inch*2 - Math.round(inch*2)) < 1e-6;
        const w = long?8:mid?5:3;
        line(group, 10, y, 10+w, y, 'rulerTick');
        if (long){ const t=text(group,18,y,Math.round(inch),'ruLbl',90); t.dataset.arm=which; t.dataset.x=18; t.dataset.y=y; }
      }
      const tcm=text(group,-26,tipY,'cm','ruLbl',-90); tcm.dataset.arm=which; tcm.dataset.x=-26; tcm.dataset.y=tipY;
      const tin=text(group, 26,tipY,'in','ruLbl', 90); tin.dataset.arm=which; tin.dataset.x= 26; tin.dataset.y=tipY;
    }

    // state
    let mov=0, gRot=0, zoom=1, panX=0, panY=0, mirrored=false;

    function applyView(){ viewport.setAttribute('transform', `translate(${panX},${panY}) scale(${zoom})`); }
    function applyRot(){ rotWrap.setAttribute('transform', `rotate(${gRot})`); }
    function applyMirror(){ mirrorWrap.setAttribute('transform', `scale(${mirrored?-1:1},1)`); }
    function applyLabelFix(){
      const sx = mirrored ? -1 : 1;
      document.getElementById('labelsFixed').setAttribute('transform', `scale(${sx},1) rotate(${-gRot})`);
      numsInWrap.setAttribute('transform', `rotate(${sx * gRot})`);
    }
    function render(){
      armA_grp.setAttribute('transform', `rotate(0)`);
      armB_grp.setAttribute('transform', `rotate(${mov})`);
      document.querySelectorAll('.ruLbl').forEach(t=>{
        const which=t.dataset.arm; const base = (which==='A'? 0 : mov) + gRot;
        const x=+t.dataset.x, y=+t.dataset.y;
        t.setAttribute('transform', `rotate(${-base} ${x} ${y})`);
      });
      const d180 = (mov>180)? 360-mov : mov;
      a180.textContent = Math.round(d180)+'¬∞';
    }

    // gestures (touch) + wheel zoom
    let touches=new Map(), lastGesture=null;
    const tp = e => ({x:e.clientX,y:e.clientY});
    const ctr=(a,b)=>({x:(a.x+b.x)/2,y:(a.y+b.y)/2});
    const dst=(a,b)=>Math.hypot(a.x-b.x,a.y-b.y);
    const ang=(a,b)=>Math.atan2(b.y-a.y,b.x-a.x)*180/Math.PI;

    svg.addEventListener('pointerdown', e=>{ if(e.pointerType==='touch'){ touches.set(e.pointerId, tp(e)); startG(); }});
    svg.addEventListener('pointermove', e=>{ if(e.pointerType==='touch' && touches.has(e.pointerId)){ touches.set(e.pointerId, tp(e)); moveG(); }});
    svg.addEventListener('pointerup',   e=>{ if(touches.delete(e.pointerId)) endG(); });
    svg.addEventListener('pointercancel', e=>{ if(touches.delete(e.pointerId)) endG(); });

    function startG(){ if(touches.size===2){ const [a,b]=[...touches.values()]; lastGesture={c:ctr(a,b), d:dst(a,b), a:ang(a,b), panX, panY, zoom, gRot}; } }
    function moveG(){
      if(touches.size!==2 || !lastGesture) return;
      const [a,b]=[...touches.values()];
      const c=ctr(a,b), d=dst(a,b), ag=ang(a,b);
      zoom = Math.min(4, Math.max(0.4, lastGesture.zoom*(d/lastGesture.d)));
      panX = lastGesture.panX + (c.x - lastGesture.c.x)/zoom;
      panY = lastGesture.panY + (c.y - lastGesture.c.y)/zoom;
      let da = ag - lastGesture.a; while(da>180) da-=360; while(da<-180) da+=360;
      gRot = lastGesture.gRot + da;
      applyView(); applyRot(); applyLabelFix(); render();
    }
    function endG(){ lastGesture=null; }

    svg.addEventListener('wheel', e=>{
      e.preventDefault();
      const fac = e.deltaY>0 ? 1/1.1 : 1.1;
      const pt = svg.createSVGPoint(); pt.x=e.clientX; pt.y=e.clientY;
      const inV = pt.matrixTransform(viewport.getScreenCTM().inverse());
      const newZoom = Math.min(4, Math.max(0.4, zoom*fac));
      const k = newZoom/zoom;
      panX = inV.x - k*(inV.x - panX);
      panY = inV.y - k*(inV.y - panY);
      zoom = newZoom; applyView();
    }, {passive:false});

    document.getElementById('gonioReset').onclick = ()=>{ mov=0; gRot=0; zoom=1; mirrored=false; applyView(); applyRot(); applyMirror(); applyLabelFix(); render(); };

    // public API
    function show(){ host.classList.remove('hide'); host.setAttribute('aria-hidden','false'); bar.classList.remove('hide'); }
    function hide(){ host.classList.add('hide'); host.setAttribute('aria-hidden','true'); bar.classList.add('hide'); }

    /** Center at (cx,cy) in screen pixels; baseDeg = absolute screen angle of Stationary vector; movDeg = absolute screen angle of Moving vector. */
    function setPose(cx, cy, baseDeg, movDeg){
      // lock center to fulcrum
      panX = cx; panY = cy; zoom = 1;
      // rotate instrument so red arm points along Stationary vector
      // Our head uses 0¬∞ = up; convert screen vector (dx,dy) to that space first
      gRot = baseDeg; // baseDeg is already in "0 up" convention
      // moving arm relative to base
      mov = clamp360(movDeg - baseDeg);
      applyView(); applyRot(); applyMirror(); applyLabelFix(); render();
    }

    // expose conversion helper for screen vectors
    function degFromScreenVec(dx, dy){ return toDegUp(dx, dy); }

    return { show, hide, setPose, degFromScreenVec };
  })();

  // ===== UI =====
  const msg = document.getElementById("msg");
  const hud = document.getElementById("hud");
  const logEl = document.getElementById("log");
  const toast = document.getElementById("toast");
  const tolEl = document.getElementById("tol");
  let tol = parseFloat(tolEl.value);
  tolEl.oninput = () => (tol = parseFloat(tolEl.value));

  const canvas = document.getElementById("c");
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setPixelRatio(devicePixelRatio);
  renderer.setSize(innerWidth, innerHeight);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b1220);

  const camera = new THREE.PerspectiveCamera(45, innerWidth / innerHeight, 0.1, 100);
  camera.position.set(0.8, 1.6, 2.5);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  scene.add(new THREE.HemisphereLight(0xffffff, 0x333344, 1.2));
  const dl = new THREE.DirectionalLight(0xffffff, 1);
  dl.position.set(3, 4, 2);
  scene.add(dl);

  // ===== Floor protractor (kept) =====
  const protractor = new THREE.Group();
  scene.add(protractor);
  const radius = 1.8;
  const tickMat = new THREE.LineBasicMaterial({ color: 0x475569 });
  for (let d = 0; d < 360; d += 10) {
    const a = THREE.MathUtils.degToRad(d);
    const r1 = radius * 0.95, r2 = (d % 30 === 0) ? radius * 0.88 : radius * 0.93;
    const pts = [
      new THREE.Vector3(Math.cos(a) * r1, 0, Math.sin(a) * r1),
      new THREE.Vector3(Math.cos(a) * r2, 0, Math.sin(a) * r2)
    ];
    protractor.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), tickMat));
  }
  const makeLabel = (text) => {
    const div = document.createElement('div');
    div.textContent = text;
    div.style.position = 'fixed';
    div.style.color = '#94a3b8';
    div.style.font = '12px system-ui';
    div.style.pointerEvents = 'none';
    div.style.zIndex = 10;
    document.body.appendChild(div);
    return div;
  };
  const labels = [];
  for (let d = 0; d < 360; d += 30) labels.push({deg:d, el:makeLabel(`${d}¬∞`)});
  const tmpV = new THREE.Vector3();
  function layoutLabels() {
    labels.forEach(({deg, el})=>{
      const a = THREE.MathUtils.degToRad(deg);
      tmpV.set(Math.cos(a) * radius, 0, Math.sin(a) * radius).applyMatrix4(protractor.matrixWorld);
      tmpV.project(camera);
      const x = (tmpV.x * 0.5 + 0.5) * innerWidth;
      const y = (-tmpV.y * 0.5 + 0.5) * innerHeight;
      el.style.left = `${x - 10}px`;
      el.style.top  = `${y - 8}px`;
    });
  }

  // ===== Model loader =====
  const loader = new GLTFLoader();
  loader.setMeshoptDecoder(MeshoptDecoder);
  const draco = new DRACOLoader();
  draco.setDecoderPath("https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/");
  loader.setDRACOLoader(draco);
  const ktx2 = new KTX2Loader();
  ktx2.setTranscoderPath("https://unpkg.com/three@0.160.0/examples/jsm/libs/basis/");
  ktx2.detectSupport(renderer);
  loader.setKTX2Loader(ktx2);

  const MODEL_URL = "./Athletic_Grace_1006002620_texture.glb";
  let model = null;

  loader.load(MODEL_URL, (gltf) => {
    model = gltf.scene;
    scene.add(model);
    const box = new THREE.Box3().setFromObject(model);
    const c = box.getCenter(new THREE.Vector3());
    model.position.sub(new THREE.Vector3(c.x, 0, c.z)); // keep Y

    // Align floor protractor 0¬∞ to model anterior
    const forward = new THREE.Vector3(0,0,1).applyQuaternion(model.quaternion);
    const yaw = Math.atan2(forward.z, forward.x);
    protractor.rotation.y = yaw;

    msg.textContent = "‚úÖ Model loaded";
  }, (xhr) => {
    msg.textContent = xhr.lengthComputable ? `Loading ${Math.round((xhr.loaded/xhr.total)*100)}%` : "Loading‚Ä¶";
  }, (err) => { console.error(err); msg.textContent = "‚ùå Failed to load model (see console)"; });

  // ===== Landmarks =====
  const matGood = new THREE.MeshBasicMaterial({ color: 0x22c55e });
  const matBad  = new THREE.MeshBasicMaterial({ color: 0xef4444 });
  const dot = () => new THREE.Mesh(new THREE.SphereGeometry(0.01, 16, 16), matBad.clone());

  const user = { fulcrum: dot(), stationary: dot(), moving: dot() };
  Object.values(user).forEach(m => { m.visible = false; scene.add(m); });

  // Store local positions so markers follow animation/rig
  const userLocal = { fulcrum:null, stationary:null, moving:null };

  const ghost = { fulcrum: dot(), stationary: dot(), moving: dot() };
  Object.values(ghost).forEach(m => { m.material = new THREE.MeshBasicMaterial({ color: 0x38bdf8 });
                                      m.visible = false; scene.add(m); });

  const PRESETS = {
    cerv_flex: {
      fulcrum:   new THREE.Vector3(0.08, 1.65, 0.02),
      stationary:new THREE.Vector3(0.12, 1.55, 0.15),
      moving:    new THREE.Vector3(0.10, 1.68, 0.12)
    },
    cerv_rot: {
      fulcrum:   new THREE.Vector3(0.08, 1.80, 0.02),
      stationary:new THREE.Vector3(0.18, 1.55, 0.15),
      moving:    new THREE.Vector3(0.10, 1.70, 0.20)
    },
    cerv_lat: {
      fulcrum:   new THREE.Vector3(0.05, 1.55, 0.02),
      stationary:new THREE.Vector3(0.00, 1.45, 0.10),
      moving:    new THREE.Vector3(0.10, 1.60, 0.02)
    }
  };
  let truth = { ...PRESETS.cerv_rot };

  let ghostOn = false;
  function updateGhost() {
    ghost.fulcrum.position.copy(truth.fulcrum);
    ghost.stationary.position.copy(truth.stationary);
    ghost.moving.position.copy(truth.moving);
    Object.values(ghost).forEach(m => { m.visible = ghostOn; });
  }

  // picking
  let target = null;
  const ray = new THREE.Raycaster();
  const mouse = new THREE.Vector2();

  function log(t) {
    logEl.textContent += t + "\n";
    logEl.scrollTop = logEl.scrollHeight;
  }

  function placePoint(name, worldPoint) {
    if (!model) return;
    const local = model.worldToLocal(worldPoint.clone());
    userLocal[name] = local;
    user[name].visible = true;
    user[name].position.copy(worldPoint);
    const cm = worldPoint.distanceTo(truth[name]) * 100.0;
    user[name].material.color.set(cm <= tol ? 0x22c55e : 0xef4444);
    log(`${name}: ${cm.toFixed(1)} cm`);
    updateFromLocals(true);
  }

  canvas.addEventListener("pointerdown", (e) => {
    if (!target || !model) return;
    const r = canvas.getBoundingClientRect();
    mouse.x = ((e.clientX - r.left) / r.width) * 2 - 1;
    mouse.y = -((e.clientY - r.top) / r.height) * 2 + 1;
    ray.setFromCamera(mouse, camera);
    const hits = ray.intersectObjects(scene.children, true)
      .filter(h => !(h.object instanceof THREE.Line) && h.object !== protractor);
    if (!hits.length) return;
    placePoint(target, hits[0].point);
    target = null;
  });

  // ===== Measurement visuals (lines only; SVG goniometer handles the rest) =====
  const line1 = new THREE.Line(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0x60a5fa }));
  const line2 = new THREE.Line(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0xf472b6 }));
  scene.add(line1, line2);

  function setAngle(a) { hud.textContent = `Angle: ${a.toFixed(0)}¬∞`; }

  // project world -> screen
  const toScreen = (vec3) => {
    const v = vec3.clone().project(camera);
    return { x: (v.x * 0.5 + 0.5) * innerWidth, y: (-v.y * 0.5 + 0.5) * innerHeight };
  };

  // Update from LOCAL bindings each frame (so markers follow rig/animation)
  function updateFromLocals(force=false) {
    if (!model) return;
    ["fulcrum","stationary","moving"].forEach(k=>{
      if (userLocal[k]) {
        user[k].position.copy(userLocal[k].clone()).applyMatrix4(model.matrixWorld);
        user[k].visible = true;
      }
    });

    const f = user.fulcrum.visible ? user.fulcrum.position : null;
    const s = user.stationary.visible ? user.stationary.position : null;
    const m = user.moving.visible ? user.moving.position : null;

    // draw 3D helper lines
    line1.visible = !!(f && s);
    line2.visible = !!(f && m);
    if (line1.visible){ line1.geometry.dispose(); line1.geometry = new THREE.BufferGeometry().setFromPoints([f, s]); }
    if (line2.visible){ line2.geometry.dispose(); line2.geometry = new THREE.BufferGeometry().setFromPoints([f, m]); }

    if (f && s && m) {
      const vs = s.clone().sub(f).normalize();
      const vm = m.clone().sub(f).normalize();
      const ang = THREE.MathUtils.radToDeg(Math.acos(THREE.MathUtils.clamp(vs.dot(vm), -1, 1)));
      setAngle(ang);

      // ***** Drive SVG goniometer overlay *****
      const Fs = toScreen(f), Ss = toScreen(s), Ms = toScreen(m);
      const baseDeg = Gonio.degFromScreenVec(Ss.x - Fs.x, Ss.y - Fs.y); // Stationary (RED)
      const movDeg  = Gonio.degFromScreenVec(Ms.x - Fs.x, Ms.y - Fs.y); // Moving (GREEN)
      Gonio.show();
      Gonio.setPose(Fs.x, Fs.y, baseDeg, movDeg);
    } else {
      setAngle(0);
      Gonio.hide();
    }
  }

  // ===== Buttons & presets =====
  const pickFulcrum = document.getElementById("pickFulcrum");
  const pickStationary = document.getElementById("pickStationary");
  const pickMoving = document.getElementById("pickMoving");
  const toggleGhostBtn = document.getElementById("toggleGhost");
  const resetAll = document.getElementById("resetAll");
  const presetSel = document.getElementById("preset");
  const measureToggle = document.getElementById("measureToggle");

  let followMeasure = false;

  pickFulcrum.onclick   = () => { target = "fulcrum";   log("Place Fulcrum"); };
  pickStationary.onclick= () => { target = "stationary";log("Place Stationary"); };
  pickMoving.onclick    = () => { target = "moving";    log("Place Moving"); };

  toggleGhostBtn.onclick = () => {
    ghostOn = !ghostOn; updateGhost();
    toast.textContent = ghostOn ? "Ghost landmarks ON" : "Ghost landmarks OFF";
    showToast();
  };

  resetAll.onclick = () => {
    Object.values(user).forEach(m => m.visible = false);
    userLocal.fulcrum = userLocal.stationary = userLocal.moving = null;
    line1.visible = line2.visible = false;
    setAngle(0);
    Gonio.hide();
    log("Reset");
  };

  presetSel.onchange = () => {
    const p = presetSel.value;
    truth = { ...PRESETS[p] };
    updateGhost();
    toast.textContent = `Preset: ${presetSel.options[presetSel.selectedIndex].text}`;
    showToast();
  };

  measureToggle.onclick = () => {
    followMeasure = !followMeasure;
    measureToggle.textContent = followMeasure ? "üß≠ Measure: ON" : "üß≠ Measure: OFF";
  };

  function showToast() {
    toast.style.display = 'block';
    clearTimeout(showToast.tid);
    showToast.tid = setTimeout(()=> toast.style.display='none', 1200);
  }

  // layout + render
  addEventListener("resize", () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
    layoutLabels();
    // keep the SVG overlay centered correctly on resize
    updateFromLocals(true);
  });

  const clock = new THREE.Clock();
  (function animate() {
    const dt = clock.getDelta();
    controls.update();
    if (followMeasure) updateFromLocals();
    renderer.render(scene, camera);
    layoutLabels();
    requestAnimationFrame(animate);
  })();
</script>
</body>
</html>
