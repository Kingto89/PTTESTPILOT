<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>PT Lab ‚Äî Goniometry Trainer</title>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<style>
  html,body{margin:0;height:100%;background:#0b1220;color:#e5e7eb;overflow:hidden;font-family:system-ui,Segoe UI,Roboto}
  canvas{position:fixed; inset:0; z-index:0; width:100%; height:100%; display:block}
  .panel{
    position:fixed; left:0; top:0; bottom:0; width:340px;
    background:#0f172a; border-right:1px solid #1f2937; padding:14px; overflow:auto; z-index:50;
  }
  #gonioHost{position:fixed; inset:0; z-index:30; pointer-events:none}
  #gonioHost svg{width:100vw;height:100vh;background:transparent;pointer-events:auto}
  .hud,.toast,#msg{z-index:40}
  .hud{position:fixed;top:10px;left:50%;transform:translateX(-50%);background:rgba(15,23,42,.75);border:1px solid #334155;border-radius:10px;padding:6px 10px;font-weight:700;backdrop-filter:blur(6px)}
  .toast{position:fixed;bottom:10px;left:50%;transform:translateX(-50%);background:rgba(2,6,23,.7);border:1px solid #334155;border-radius:10px;padding:6px 10px;font-size:13px;display:none}
  #msg{position:fixed;top:10px;left:10px;background:rgba(15,23,42,.7);border:1px solid #334155;border-radius:8px;padding:6px 10px;font-size:13px}

  h3{margin:8px 0 12px 0}
  label{display:block;font-size:13px;margin-top:10px;color:#cbd5e1}
  select,button,input[type=range]{width:100%;margin:6px 0 8px 0;padding:8px 10px;border-radius:10px;background:#1e293b;border:1px solid #334155;color:#e2e8f0}
  .row{display:flex;gap:8px}.row>button{flex:1}
  #log{background:#0b1220;border:1px solid #1f2937;height:130px;overflow:auto;border-radius:8px;padding:8px}
  .legend{font-size:12px;color:#cbd5e1;margin-top:6px}
  .chip{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid #334155;background:#0b1220;margin-right:6px}

  .tick{stroke:#64748b;stroke-width:.9}.tickBig{stroke-width:1.6}
  .armA{stroke:#ef4444;fill:none}.armB{stroke:#22c55e;fill:none}
  .axisA{stroke:#ef4444;stroke-width:1.6;opacity:.85}.axisB{stroke:#22c55e;stroke-width:1.6;opacity:.85}
  .rulerTick{stroke:#94a3b8}
  .labelOuter{fill:#e5e7eb;font-size:11px;text-anchor:middle;dominant-baseline:middle;paint-order:stroke;stroke:#0b1220;stroke-width:3px}
  .labelInner{fill:#fca5a5;font-size:8.2px;text-anchor:middle;dominant-baseline:middle;paint-order:stroke;stroke:#0b1220;stroke-width:3px}
  .ruLbl{fill:#cbd5e1;font-size:9.5px;dominant-baseline:middle;paint-order:stroke;stroke:#0b1220;stroke-width:3px}
  .hide{display:none}.lockOn{background:#0b3a1f;border-color:#16a34a}

  /* Note panel */
  .note{
    position:fixed; right:16px; bottom:16px; width:420px; max-width:90vw;
    background:rgba(2,6,23,.8); border:1px solid #334155; border-radius:12px; z-index:60;
    box-shadow:0 10px 30px rgba(0,0,0,.35); color:#e5e7eb;
  }
  .noteHead{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid #1f2937;font-weight:700}
  .noteBody{padding:12px; font-size:14px; line-height:1.45}
  .noteClose{background:#172033;border:1px solid #334155;border-radius:8px;padding:2px 8px;color:#cbd5e1}
  .note h3,.note h4{margin:8px 0}
  .note ul{margin:6px 0 6px 18px}
</style>
</head>
<body>
<div class="panel">
  <h3>Goniometry Trainer</h3>

  <!-- Region & Motion -->
  <label>Region</label>
  <select id="regionSel"></select>

  <label>Motion</label>
  <select id="motionSel"></select>

  <button id="showNote">üìå Show goniometer placement</button>

  <div class="row">
    <button id="pickFulcrum">1Ô∏è‚É£ Fulcrum</button>
    <button id="pickStationary">2Ô∏è‚É£ Stationary</button>
    <button id="pickMoving">3Ô∏è‚É£ Moving</button>
  </div>

  <label>Options</label>
  <div class="row">
    <button id="toggleGhost">üëª Ghost Landmarks</button>
    <button id="resetAll">Reset</button>
  </div>

  <div class="row">
    <button id="measureToggle">üß≠ Measure: ON</button>
  </div>

  <label>Interaction Locks</label>
  <div class="row">
    <button id="lock3D">üîì 3D: Unlocked</button>
    <button id="lockGonio">üîì Gonio: Unlocked</button>
  </div>

  <label>Gonio Size (10‚Äì200%)</label>
  <input type="range" min="10" max="200" step="5" value="100" id="gonioSize">

  <label>Rotate Moving Arm (¬∞)</label>
  <input type="range" min="0" max="360" step="1" value="30" id="rotateMove">

  <label>Rotate Goniometer (¬∞)</label>
  <input type="range" min="0" max="360" step="1" value="0" id="rotateGonio">

  <div class="legend">
    <span class="chip" style="border-color:#ef4444">Stationary arm (red)</span>
    <span class="chip" style="border-color:#22c55e">Moving arm (green)</span>
    <span class="chip" style="border-color:#f59e0b">Fulcrum (orange)</span>
  </div>

  <label>Event Log</label>
  <pre id="log"></pre>
</div>

<!-- Note (markdown) -->
<div id="mdNote" class="note hide" role="dialog" aria-modal="true">
  <div class="noteHead">
    <div id="mdTitle">Note</div>
    <button id="mdClose" class="noteClose">‚úï</button>
  </div>
  <div id="mdBody" class="noteBody">Loading‚Ä¶</div>
</div>

<!-- SVG goniometer -->
<div id="gonioHost" class="hide" aria-hidden="true">
  <svg id="gonioSvg" aria-label="Universal goniometer">
    <g id="viewport" transform="translate(0,0) scale(1)">
      <g id="rotWrap" transform="rotate(0)">
        <g id="mirrorWrap" transform="scale(1,1)">
          <g id="instrument">
            <g id="head">
              <!-- center is transparent -->
              <circle r="120" fill="none" stroke="#94a3b8" stroke-width="1.6"/>
              <circle r="86"  fill="none" stroke="#94a3b8" stroke-width="0.9" opacity="0.65"/>
              <g id="ticks"></g>
              <g id="labelsFixed">
                <g id="numsOut"></g>
                <g id="numsInWrap"><g id="numsIn"></g></g>
              </g>
              <circle r="3.2" fill="#94a3b8"/>
            </g>

            <!-- RED stationary arm -->
            <g id="armA_grp">
              <rect class="armA" x="-10" y="120" width="20" height="260" rx="10" stroke-width="3" />
              <line id="axisA" class="axisA" x1="0" y1="380" x2="0" y2="-116" stroke-linecap="round"/>
              <g id="armA_ruler"></g>
              <circle id="armA_knob" cx="0" cy="380" r="10" fill="#ef4444"/>
            </g>

            <!-- GREEN moving arm -->
            <g id="armB_grp">
              <rect class="armB" x="-10" y="-380" width="20" height="500" rx="10" stroke-width="3"/>
              <line id="axisB" class="axisB" x1="0" y1="-380" x2="0" y2="124" stroke-linecap="round"/>
              <g id="armB_ruler"></g>
              <circle id="armB_knob" cx="0" cy="-380" r="10" fill="#22c55e"/>
              <circle id="armB_handleKnob" cx="0" cy="-380" r="38" fill="rgba(0,0,0,0)" style="pointer-events:all"/>
              <rect   id="armB_handleShaft" x="-20" y="-380" width="40" height="500" fill="rgba(0,0,0,0)" style="pointer-events:all"/>
            </g>
          </g>
        </g>
      </g>
    </g>
  </svg>
</div>

<div id="msg">Loading‚Ä¶</div>
<div class="hud" id="hud">Angle: 0¬∞</div>
<div class="toast" id="toast">Preset updated</div>
<canvas id="c"></canvas>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";
import { KTX2Loader } from "three/addons/loaders/KTX2Loader.js";
import { MeshoptDecoder } from "three/addons/libs/meshopt_decoder.module.js";
import { EXRLoader } from "three/addons/loaders/EXRLoader.js";

/* ===== Config ===== */
const S = { MIN_ZOOM:0.07, MAX_ZOOM:10, WHEEL_STEP:1.22, WHEEL_ACCEL:1/120,
            PINCH_EXP:1.25, ROT_GAIN:1.25, PAN_GAIN:1,
            PX_PER_CM:37.7952755906, MARGIN_CM:4, INSTR_BASE_RADIUS_PX:140 };
const MARGIN_PX = S.PX_PER_CM * S.MARGIN_CM;
const CONTENT_BASE = "./content/goniometry";

/* ===== UI ===== */
const msg = document.getElementById("msg");
const hud = document.getElementById("hud");
const logEl = document.getElementById("log");
const toast = document.getElementById("toast");
const lock3DBtn = document.getElementById("lock3D");
const lockGonioBtn = document.getElementById("lockGonio");
const sizeEl = document.getElementById("gonioSize");
const rotateMoveEl = document.getElementById("rotateMove");
const rotateGonioEl = document.getElementById("rotateGonio");
const regionSel = document.getElementById("regionSel");
const motionSel = document.getElementById("motionSel");
const showNoteBtn = document.getElementById("showNote");
const mdNote = document.getElementById("mdNote");
const mdTitle = document.getElementById("mdTitle");
const mdBody = document.getElementById("mdBody");
document.getElementById("mdClose").onclick = () => mdNote.classList.add("hide");
const log = (t)=>{ logEl.textContent += t + "\n"; logEl.scrollTop = logEl.scrollHeight; };

/* ===== Region/Motion lists (labels only) ===== */
const REGIONS = {
  cervical_spine: { label:"Cervical Spine",
    motions:["Flexion","Extension","Rotation","Lateral Bending"] },
  thoracic_lumbar_spine: { label:"Lumbar & Thoracic Spine",
    motions:["Flexion","Extension","Rotation","Lateral Flexion"] },
  glenohumeral_joint: { label:"Glenohumeral Joint",
    motions:["Flexion","Extension","Abduction","Adduction","Internal Rotation","External Rotation"] },
  elbow_radioulnar: { label:"Elbow & Radioulnar Joints",
    motions:["Flexion","Extension","Pronation","Supination"] },
  wrist: { label:"Wrist",
    motions:["Flexion","Extension","Radial Deviation","Ulnar Deviation"] },
  hip: { label:"Hip",
    motions:["Flexion","Extension","Abduction","Adduction","Internal Rotation","External Rotation"] },
  knee: { label:"Knee",
    motions:["Flexion","Extension"] },
  talocrural_ankle: { label:"Talocrural",
    motions:["Dorsiflexion","Plantarflexion"] },
  transverse_tarsal_subtalar: { label:"Transverse Tarsal & Subtalar Joints",
    motions:["Inversion","Eversion"] },
  fingers_mcp_pip_dip: { label:"Fingers (MCP, PIP, & DIP Joints)",
    motions:["MCP Flexion","MCP Extension","PIP Flexion","PIP Extension","DIP Flexion","DIP Extension"] },
  thumb_cmc_mcp_ip: { label:"Thumb (CMC, MCP, & IP Joints)",
    motions:["CMC Abduction","CMC Flexion","CMC Extension","MCP Flexion","MCP Extension","IP Flexion","IP Extension"] },
  toes_mtp_pip_dip: { label:"Toes (MTP, PIP, & DIP Joints)",
    motions:["MTP Flexion","MTP Extension","PIP Flexion","PIP Extension","DIP Flexion","DIP Extension"] }
};
(function buildRegionMotion(){
  for (const k of Object.keys(REGIONS)){
    const o=document.createElement('option'); o.value=k; o.textContent=REGIONS[k].label;
    regionSel.appendChild(o);
  }
  regionSel.value="cervical_spine";
  function rebuildMotion(){
    const r=REGIONS[regionSel.value]; motionSel.innerHTML="";
    r.motions.forEach(m=>{ const o=document.createElement('option'); o.value=m; o.textContent=m; motionSel.appendChild(o); });
  }
  regionSel.onchange=rebuildMotion; rebuildMotion();
})();

/* ===== Three.js ===== */
const canvas = document.getElementById("c");
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
renderer.setPixelRatio(devicePixelRatio);
renderer.setSize(innerWidth, innerHeight);

const scene = new THREE.Scene(); // background will be set by EXR below

// EXR environment (background + lighting)
const pmrem = new THREE.PMREMGenerator(renderer);
pmrem.compileEquirectangularShader();
new EXRLoader()
  .setPath("assets/")
  .load("pt_evaluation_room.exr", (exrTex) => {
    const envMap = pmrem.fromEquirectangular(exrTex).texture;
    scene.environment = envMap;
    scene.background  = exrTex; // nice crisp background
    exrTex.dispose();
  });

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 100);
camera.position.set(0.8, 1.6, 2.5);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.enabled = true;
lock3DBtn.textContent = "üîì 3D: Unlocked";
lock3DBtn.classList.remove("lockOn");

// supplemental lights if EXR is dark
scene.add(new THREE.HemisphereLight(0xffffff, 0x333344, 0.6));
const dl = new THREE.DirectionalLight(0xffffff, 0.6); dl.position.set(3, 4, 2); scene.add(dl);

/* Model loader (Grace) with fallback mannequin */
const loader = new GLTFLoader();
loader.setMeshoptDecoder(MeshoptDecoder);
const draco = new DRACOLoader(); draco.setDecoderPath("https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/");
loader.setDRACOLoader(draco);
const ktx2 = new KTX2Loader(); ktx2.setTranscoderPath("https://unpkg.com/three@0.160.0/examples/jsm/libs/basis/");
ktx2.detectSupport(renderer); loader.setKTX2Loader(ktx2);

let model = null;
const MODEL_URL = "./Athletic_Grace_1006002620_texture.glb";

function addFallbackMannequin(){
  if (model) return;
  const g = new THREE.Group();
  const mat = new THREE.MeshStandardMaterial({color:0xa0a4ae, metalness:0.1, roughness:0.8});
  const mk = (geo,y,s=1)=>{ const m=new THREE.Mesh(geo,mat); m.position.y=y; m.scale.setScalar(s); g.add(m); };
  mk(new THREE.CapsuleGeometry(0.22,0.8,8,16), 1.1);
  mk(new THREE.SphereGeometry(0.16,16,16),        1.8);
  mk(new THREE.CylinderGeometry(0.1,0.12,0.3,12), 1.45);
  mk(new THREE.CylinderGeometry(0.11,0.11,0.8,12),0.55);
  scene.add(g); model = g;
  msg.textContent = "‚ö†Ô∏è GLB missing/blocked ‚Äî fallback mannequin shown";
}
async function loadModel() {
  try {
    const head = await fetch(MODEL_URL, { method: "HEAD", cache: "no-store" });
    if (!head.ok) { msg.textContent = `‚ö†Ô∏è ${MODEL_URL} (HTTP ${head.status}) ‚Äî using fallback`; addFallbackMannequin(); return; }
  } catch { msg.textContent = `‚ö†Ô∏è Network error ‚Äî using fallback`; addFallbackMannequin(); return; }
  loader.load(MODEL_URL, (gltf) => {
    model = gltf.scene; scene.add(model);
    const box = new THREE.Box3().setFromObject(model);
    const c = box.getCenter(new THREE.Vector3());
    model.position.sub(new THREE.Vector3(c.x, 0, c.z));
    msg.textContent = "‚úÖ Model loaded";
  }, (xhr) => {
    msg.textContent = xhr.lengthComputable ? `Loading ${Math.round((xhr.loaded/xhr.total)*100)}%` : "Loading‚Ä¶";
  }, () => { msg.textContent = "‚ö†Ô∏è Loader error ‚Äî using fallback"; addFallbackMannequin(); });
  setTimeout(()=>{ if (!model) addFallbackMannequin(); }, 6000);
}
loadModel();

/* Landmarks ‚Äî colored dots */
const COLORS = { stationary: 0xef4444, moving: 0x22c55e, fulcrum: 0xf59e0b, ghost: 0x38bdf8 };
const dot = (color) => new THREE.Mesh(new THREE.SphereGeometry(0.01, 16, 16), new THREE.MeshBasicMaterial({ color }));
const user = { fulcrum: dot(COLORS.fulcrum), stationary: dot(COLORS.stationary), moving: dot(COLORS.moving) };
Object.values(user).forEach(m => { m.visible = false; scene.add(m); });
const userLocal = { fulcrum:null, stationary:null, moving:null };

const ghost = { fulcrum: dot(COLORS.ghost), stationary: dot(COLORS.ghost), moving: dot(COLORS.ghost) };
Object.values(ghost).forEach(m => { m.visible = false; scene.add(m); });

const PRESETS = {
  cerv_flex: { fulcrum:new THREE.Vector3(0.08,1.65,0.02), stationary:new THREE.Vector3(0.12,1.55,0.15), moving:new THREE.Vector3(0.10,1.68,0.12) },
  cerv_rot:  { fulcrum:new THREE.Vector3(0.08,1.80,0.02), stationary:new THREE.Vector3(0.18,1.55,0.15), moving:new THREE.Vector3(0.10,1.70,0.20) },
  cerv_lat:  { fulcrum:new THREE.Vector3(0.05,1.55,0.02), stationary:new THREE.Vector3(0.00,1.45,0.10), moving:new THREE.Vector3(0.10,1.60,0.02) }
};
let truth = { ...PRESETS.cerv_rot };
let ghostOn = false; function updateGhost(){ ghost.fulcrum.position.copy(truth.fulcrum); ghost.stationary.position.copy(truth.stationary); ghost.moving.position.copy(truth.moving); Object.values(ghost).forEach(m => m.visible = ghostOn); }

let target = null;
const ray = new THREE.Raycaster();
const mouse = new THREE.Vector2();
function toScreen(v3){ const v=v3.clone().project(camera); return { x:(v.x*0.5+0.5)*innerWidth, y:(-v.y*0.5+0.5)*innerHeight }; }

function placePoint(name, worldPoint) {
  if (!model) return;
  const local = model.worldToLocal(worldPoint.clone());
  userLocal[name] = local;
  user[name].visible = true;
  user[name].position.copy(worldPoint);
  log(`${name} placed`);
  updateFromLocals();
}
canvas.addEventListener("pointerdown", (e) => {
  if (!target || !model) return;
  const r = canvas.getBoundingClientRect();
  mouse.x = ((e.clientX - r.left) / r.width) * 2 - 1;
  mouse.y = -((e.clientY - r.top) / r.height) * 2 + 1;
  ray.setFromCamera(mouse, camera);
  const hits = ray.intersectObjects(scene.children, true)
    .filter(h => !(h.object instanceof THREE.Line));
  if (!hits.length) return;
  placePoint(target, hits[0].point); target = null;
});

const line1 = new THREE.Line(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: COLORS.stationary }));
const line2 = new THREE.Line(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: COLORS.moving }));
scene.add(line1, line2);

function setAngle(a, romText=""){ hud.textContent = romText ? `Angle: ${a.toFixed(0)}¬∞ | ${romText}` : `Angle: ${a.toFixed(0)}¬∞`; }

/* ROM tracker */
let romOn = true, romStartDeg = 0;
function resetROM(currentDeg){ romStartDeg = currentDeg; }
document.getElementById("measureToggle").onclick = ()=>{
  romOn = !romOn;
  document.getElementById("measureToggle").textContent = romOn ? "üß≠ Measure: ON" : "üß≠ Measure: OFF";
  if (romOn) resetROM(Gonio.angle);
};

function autoAlignGonioFromDots(f, s, m){
  const Fs = toScreen(f), Ss = toScreen(s), Ms = toScreen(m);
  const baseDeg = Gonio.degFromScreenVec(Ss.x - Fs.x, Ss.y - Fs.y);
  const movDeg  = Gonio.degFromScreenVec(Ms.x - Fs.x, Ms.y - Fs.y);
  Gonio.show(); Gonio.setPose(Fs.x, Fs.y, baseDeg, movDeg);
  rotateGonioEl.value = Math.round(Gonio.getUserRot());
  rotateMoveEl.value  = Math.round(Gonio.getMovDegAbs());
  resetROM(Gonio.angle);
}
function updateFromLocals() {
  if (!model) return;
  ["fulcrum","stationary","moving"].forEach(k=>{
    if (userLocal[k]) { user[k].position.copy(userLocal[k].clone()).applyMatrix4(model.matrixWorld); user[k].visible = true; }
  });
  const f = user.fulcrum.visible ? user.fulcrum.position : null;
  const s = user.stationary.visible ? user.stationary.position : null;
  const m = user.moving.visible ? user.moving.position : null;

  line1.visible = !!(f && s); line2.visible = !!(f && m);
  if (line1.visible){ line1.geometry.dispose(); line1.geometry = new THREE.BufferGeometry().setFromPoints([f, s]); }
  if (line2.visible){ line2.geometry.dispose(); line2.geometry = new THREE.BufferGeometry().setFromPoints([f, m]); }

  if (f && s && m) {
    const vs = s.clone().sub(f).normalize(); const vm = m.clone().sub(f).normalize();
    const ang = THREE.MathUtils.radToDeg(Math.acos(THREE.MathUtils.clamp(vs.dot(vm), -1, 1)));
    autoAlignGonioFromDots(f,s,m);
    const rom = romOn ? Math.abs(Gonio.angle - romStartDeg) : 0;
    setAngle(Gonio.angle, romOn ? `ROM: ${rom.toFixed(0)}¬∞ (start ${romStartDeg.toFixed(0)}¬∞)` : "");
  } else {
    setAngle(0); Gonio.hide();
  }
}

/* Buttons */
const pickFulcrum = document.getElementById("pickFulcrum");
const pickStationary = document.getElementById("pickStationary");
const pickMoving = document.getElementById("pickMoving");
const toggleGhostBtn = document.getElementById("toggleGhost");
const resetAll = document.getElementById("resetAll");
let followMeasure = true;

pickFulcrum.onclick   = () => { target = "fulcrum";   log("Place Fulcrum");   };
pickStationary.onclick= () => { target = "stationary";log("Place Stationary"); };
pickMoving.onclick    = () => { target = "moving";    log("Place Moving");    };

toggleGhostBtn.onclick = () => { ghostOn=!ghostOn; updateGhost(); toast.textContent = ghostOn ? "Ghost landmarks ON" : "Ghost landmarks OFF"; showToast(); };
resetAll.onclick = () => {
  Object.values(user).forEach(m => m.visible = false);
  userLocal.fulcrum = userLocal.stationary = userLocal.moving = null;
  line1.visible = line2.visible = false; setAngle(0); Gonio.hide(); log("Reset");
};

/* Locks */
let lock3D=false, lockGonio=false;
function set3DLock(v){ lock3D=v; controls.enabled=!lock3D; lock3DBtn.textContent=(lock3D? "üîí 3D: Locked":"üîì 3D: Unlocked"); lock3DBtn.classList.toggle('lockOn', lock3D); }
function setGonioLock(v){
  lockGonio=v;
  document.getElementById('instrument').style.pointerEvents = lockGonio ? 'none' : 'auto';
  lockGonioBtn.textContent=(lockGonio? "üîí Gonio: Locked":"üîì Gonio: Unlocked");
  lockGonioBtn.classList.toggle('lockOn', lockGonio);
}
set3DLock(lock3D); setGonioLock(lockGonio);
lock3DBtn.onclick = ()=> set3DLock(!lock3D);
lockGonioBtn.onclick = ()=> setGonioLock(!lockGonio);

sizeEl.oninput = ()=> { Gonio.setScale(parseInt(sizeEl.value,10)/100); Gonio.refresh(); };

rotateMoveEl.oninput = ()=>{ if (lockGonio) return; Gonio.setMovDegAbs(parseFloat(rotateMoveEl.value));
  const rom = romOn ? Math.abs(Gonio.angle - romStartDeg) : 0;
  setAngle(Gonio.angle, romOn ? `ROM: ${rom.toFixed(0)}¬∞ (start ${romStartDeg.toFixed(0)}¬∞)` : "");
};
rotateGonioEl.oninput = ()=>{ if (lockGonio) return; Gonio.setUserRot(parseFloat(rotateGonioEl.value));
  const rom = romOn ? Math.abs(Gonio.angle - romStartDeg) : 0;
  setAngle(Gonio.angle, romOn ? `ROM: ${rom.toFixed(0)}¬∞ (start ${romStartDeg.toFixed(0)}¬∞)` : "");
};

function showToast(){ toast.style.display='block'; clearTimeout(showToast.tid); showToast.tid=setTimeout(()=>toast.style.display='none',1200); }

/* ===== Markdown note loader (region file -> motion section) ===== */
async function loadMarkdown(regionKey, motionName){
  const filePath = `${CONTENT_BASE}/${regionKey}.md`;
  mdTitle.textContent = `${REGIONS[regionKey]?.label || "Region"} ‚Äî ${motionName}`;
  mdBody.textContent = "Loading‚Ä¶";

  const md2html = (txt) => txt
    .replace(/^### (.*)$/gm, "<h5>$1</h5>")
    .replace(/^## (.*)$/gm, "<h4>$1</h4>")
    .replace(/^# (.*)$/gm, "<h3>$1</h3>")
    .replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>")
    .replace(/\*(.*?)\*/g, "<em>$1</em>")
    .replace(/^- (.*)$/gm, "<li>$1</li>")
    .replace(/(<li>.*<\/li>)/gs, "<ul>$1</ul>")
    .replace(/\n/g,"<br/>");

  function extractSection(md, motionHeading){
    const src = md.replace(/\r\n/g, "\n");
    const startRe = new RegExp(`^##\\s+${motionHeading}\\s*$`, "m");
    const m = src.match(startRe);
    if (!m) return null;
    const startIdx = m.index + m[0].length;
    const rest = src.slice(startIdx);
    const next = rest.match(/^##\s+/m);
    const endIdx = next ? startIdx + next.index : src.length;
    return src.slice(startIdx, endIdx).trim();
  }

  try{
    const res = await fetch(filePath, { cache: "no-store" });
    if (res.ok){
      const fullMd = await res.text();
      const section = extractSection(fullMd, motionSel.value);
      if (section) { mdBody.innerHTML = md2html(section); mdNote.classList.remove("hide"); return; }
    }
  }catch(_){}

  mdBody.innerHTML = "<em>No note found yet for this motion.</em>";
  mdNote.classList.remove("hide");
}

showNoteBtn.onclick = () => loadMarkdown(regionSel.value, motionSel.value);

/* Render loop */
addEventListener("resize", () => {
  camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
  Gonio._clampNow?.();
});
const clock = new THREE.Clock();
(function animate(){
  clock.getDelta();
  controls.update();
  if (!document.getElementById('gonioHost').classList.contains('hide')){
    const rom = romOn ? Math.abs(Gonio.angle - romStartDeg) : 0;
    setAngle(Gonio.angle, romOn ? `ROM: ${rom.toFixed(0)}¬∞ (start ${romStartDeg.toFixed(0)}¬∞)` : "");
  }
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
})();

/* ===== SVG goniometer module ===== */
const Gonio = (() => {
  const host  = document.getElementById('gonioHost');
  const svg   = document.getElementById('gonioSvg');
  const viewport   = document.getElementById('viewport');
  const rotWrap    = document.getElementById('rotWrap');
  const numsInWrap = document.getElementById('numsInWrap');
  const labelsFixed= document.getElementById('labelsFixed');
  const armA_ruler = document.getElementById('armA_ruler');
  const armB_ruler = document.getElementById('armB_ruler');

  const clamp=(v,a,b)=>Math.min(b,Math.max(a,v));
  const clamp360=a=>(a%360+360)%360;
  const toDegUp=(x,y)=>clamp360(Math.atan2(-y,x)*180/Math.PI+90);

  (function build(){
    const ticks = document.getElementById('ticks');
    const numsOut = document.getElementById('numsOut');
    const numsIn = document.getElementById('numsIn');
    const R=120, Rin=86;
    const line=(p,x1,y1,x2,y2,cls)=>{ const n=document.createElementNS('http://www.w3.org/2000/svg','line'); n.setAttribute('x1',x1);n.setAttribute('y1',y1);n.setAttribute('x2',x2);n.setAttribute('y2',y2); if(cls)n.setAttribute('class',cls); p.appendChild(n); };
    const text=(p,x,y,t,cls,rot)=>{ const n=document.createElementNS('http://www.w3.org/2000/svg','text'); n.setAttribute('x',x); n.setAttribute('y',y); n.setAttribute('class',cls||'labelOuter'); if(rot)n.setAttribute('transform',`rotate(${rot} ${x} ${y})`); n.textContent=t; p.appendChild(n); return n; };
    for(let d=0; d<360; d+=5){ const a=(d-90)*Math.PI/180, big=d%30===0, len=big?12:6; line(ticks,Math.cos(a)*(R-len),Math.sin(a)*(R-len),Math.cos(a)*R,Math.sin(a)*R,big?'tick tickBig':'tick'); }
    const rWhite=R-8;
    for(let d=0; d<360; d+=10){ const diff90=Math.abs(((d-90)%360+540)%360-180); const diff270=Math.abs(((d-270)%360+540)%360-180); const val=Math.min(diff90,diff270); if(val%20===0 && val<=80){ const a=(d-90)*Math.PI/180,x=Math.cos(a)*rWhite,y=Math.sin(a)*rWhite; text(numsOut,x,y,String(val),'labelOuter'); } }
    const rInner=Rin+9, valFromTheta=th=>{const t=(th+180)%360; return t<=180?t:360-t;};
    for(let th=0; th<360; th+=10){ const v=valFromTheta(th); if(v%10!==0) continue; if(v===0 && th!==180) continue; const a=(th-90)*Math.PI/180,x=Math.cos(a)*rInner,y=Math.sin(a)*rInner; text(numsIn,x,y,String(v),'labelInner'); }

    buildTipRuler(armA_ruler, +380, +1, 'A');
    buildTipRuler(armB_ruler, -380, -1, 'B');
    function buildTipRuler(group, tipY, dir, which){
      const CM_TO_PX = 14, IN_TO_CM = 2.5;
      group.innerHTML='';
      const line2=(x1,y1,x2,y2)=>{const n=document.createElementNS('http://www.w3.org/2000/svg','line');n.setAttribute('x1',x1);n.setAttribute('y1',y1);n.setAttribute('x2',x2);n.setAttribute('y2',y2);n.setAttribute('class','rulerTick');group.appendChild(n);};
      const label=(x,y,t,rot)=>{const n=document.createElementNS('http://www.w3.org/2000/svg','text');n.setAttribute('x',x);n.setAttribute('y',y);n.setAttribute('class','ruLbl'); if(rot) n.setAttribute('transform',`rotate(${rot} ${x} ${y})`); n.textContent=t; n.dataset.arm=which; n.dataset.x=x; n.dataset.y=y; group.appendChild(n); return n;};
      const cmMax=15, inMax=6;
      for(let cm=0; cm<=cmMax+1e-6; cm+=0.5){
        const y = tipY - dir*(cm*CM_TO_PX);
        const long = Math.abs(cm - Math.round(cm)) < 1e-6;
        const mid  = !long && Math.abs(cm*2 - Math.round(cm*2)) < 1e-6;
        const w = long?8:mid?5:3; line2(-10,y,-10-w,y);
        if (long) label(-18,y,String(Math.round(cm)),-90);
      }
      for(let inch=0; inch<=inMax+1e-6; inch+=0.5){
        const y = tipY - dir*(inch*IN_TO_CM*CM_TO_PX);
        const long = Math.abs(inch - Math.round(inch)) < 1e-6;
        const mid  = !long && Math.abs(inch*2 - Math.round(inch*2)) < 1e-6;
        const w = long?8:mid?5:3; line2(10,y,10+w,y);
        if (long) label(18,y,String(Math.round(inch)),90);
      }
      label(-26,tipY,'cm',-90); label(26,tipY,'in',90);
    }
  })();

  let mov=30, zoom=1, panX=innerWidth/2, panY=innerHeight/2;
  let baseRot=0, userRot=0, scale=1;
  let draggingArm=false, draggingPan=false, lastPanScreen=null;

  function applyView(){ viewport.setAttribute('transform',`translate(${panX},${panY}) scale(${zoom*scale})`); }
  function applyRot(){ rotWrap.setAttribute('transform',`rotate(${baseRot+userRot})`); }
  function applyLabelFix(){ const t=-(baseRot+userRot); labelsFixed.setAttribute('transform',`rotate(${t})`); numsInWrap.setAttribute('transform',`rotate(${-t})`); }
  function updateRulerUpright(){
    const labels = document.querySelectorAll('.ruLbl');
    labels.forEach(t=>{
      const which=t.dataset.arm;
      const base = (which==='A'? 0 : mov) + baseRot + userRot;
      const x=+t.dataset.x, y=+t.dataset.y;
      t.setAttribute('transform', `rotate(${-base} ${x} ${y})`);
    });
  }

  function clampPanToViewport(){
    const bound = S.INSTR_BASE_RADIUS_PX * zoom * scale;
    const minX = MARGIN_PX + bound, maxX = innerWidth - MARGIN_PX - bound;
    const minY = MARGIN_PX + bound, maxY = innerHeight - MARGIN_PX - bound;
    if (minX <= maxX) panX = Math.min(maxX, Math.max(minX, panX)); else panX = innerWidth/2;
    if (minY <= maxY) panY = Math.min(maxY, Math.max(minY, panY)); else panY = innerHeight/2;
  }
  function clampNow(){ clampPanToViewport(); applyView(); }

  function render(){
    document.getElementById('armA_grp').setAttribute('transform','rotate(0)');
    document.getElementById('armB_grp').setAttribute('transform',`rotate(${mov})`);
    updateRulerUpright();
  }
  clampPanToViewport(); applyView(); applyRot(); applyLabelFix(); render();

  /* Drag pan (disabled when locked) */
  svg.addEventListener('pointerdown', e=>{
    if (lockGonio) return;
    if (e.target.closest('#armB_grp')) return;
    e.preventDefault(); draggingPan = true;
    lastPanScreen = { x: e.clientX, y: e.clientY };
    svg.setPointerCapture?.(e.pointerId);
  });
  svg.addEventListener('pointermove', e=>{
    if (lockGonio) return;
    if (!draggingPan || !lastPanScreen) return;
    e.preventDefault();
    const dx = (e.clientX - lastPanScreen.x) / (zoom * scale);
    const dy = (e.clientY - lastPanScreen.y) / (zoom * scale);
    panX += S.PAN_GAIN * dx; panY += S.PAN_GAIN * dy;
    lastPanScreen = { x: e.clientX, y: e.clientY };
    clampPanToViewport(); applyView();
  });
  svg.addEventListener('pointerup',   ()=>{ draggingPan=false; lastPanScreen=null; });
  svg.addEventListener('pointercancel',()=>{ draggingPan=false; lastPanScreen=null; });

  svg.addEventListener('wheel', e=>{
    if (lockGonio) return;
    e.preventDefault();
    const step=Math.sign(e.deltaY)<0?S.WHEEL_STEP:1/S.WHEEL_STEP;
    const accel=Math.exp(Math.log(S.WHEEL_STEP)*Math.abs(e.deltaY)*S.WHEEL_ACCEL);
    const fac=Math.sign(e.deltaY)<0?step*accel:(1/(step*accel));
    const newZoom=Math.min(S.MAX_ZOOM,Math.max(S.MIN_ZOOM,zoom*fac));
    const k=newZoom/zoom;
    const pt=viewport.ownerSVGElement.createSVGPoint(); pt.x=e.clientX; pt.y=e.clientY;
    const loc=pt.matrixTransform(viewport.getScreenCTM().inverse());
    panX = loc.x - k*(loc.x - panX); panY = loc.y - k*(loc.y - panY);
    zoom=newZoom; clampPanToViewport(); applyView();
  }, {passive:false});

  /* GREEN ARM DRAG */
  function startArmDrag(e){
    if (lockGonio) return;
    e.stopPropagation(); e.preventDefault();
    document.getElementById('armB_grp').setPointerCapture?.(e.pointerId);
    draggingArm = true;
  }
  function moveArm(e){
    if (lockGonio) return;
    if(!draggingArm) return;
    e.stopPropagation(); e.preventDefault();
    const pt = svg.createSVGPoint(); pt.x=e.clientX; pt.y=e.clientY;
    const p = pt.matrixTransform(rotWrap.getScreenCTM().inverse());
    mov = toDegUp(p.x, p.y);
    render();
  }
  function endArm(){ draggingArm=false; }

  ['armB_handleKnob','armB_handleShaft','armB_grp','armB_knob'].forEach(id=>{
    const el=document.getElementById(id);
    if(!el) return;
    el.addEventListener('pointerdown', startArmDrag);
    el.addEventListener('pointermove', moveArm);
    el.addEventListener('pointerup', endArm);
    el.addEventListener('pointercancel', endArm);
  });

  function show(){ host.classList.remove('hide'); host.setAttribute('aria-hidden','false'); clampPanToViewport(); applyView(); }
  function hide(){ host.classList.add('hide'); host.setAttribute('aria-hidden','true'); }
  function setPose(cx,cy,baseDeg,movDeg){ panX=cx; panY=cy; baseRot=baseDeg; mov=clamp360(movDeg-baseDeg); clampPanToViewport(); applyView(); applyRot(); applyLabelFix(); render(); }
  function setScale(k){ scale=Math.min(2,Math.max(0.1,k||1)); clampPanToViewport(); applyView(); }
  function degFromScreenVec(dx,dy){ return toDegUp(dx,dy); }

  // slider helpers
  function setMovDegAbs(deg){ mov = clamp360(deg); render(); }
  function setUserRot(deg){ userRot = clamp360(deg); applyRot(); applyLabelFix(); render(); }
  function getUserRot(){ return clamp360(userRot); }
  function getMovDegAbs(){ return clamp360(mov); }

  function currentAngle(){ const a = clamp360(mov); return a>180 ? 360-a : a; }
  return {
    show, hide, setPose, setScale, degFromScreenVec, _clampNow:clampNow,
    setMovDegAbs, setUserRot, getUserRot, getMovDegAbs,
    get angle(){ return currentAngle(); },
    refresh: ()=>{ applyView(); applyRot(); applyLabelFix(); render(); }
  };
})();
window.Gonio = Gonio;

/* Errors in-page */
window.addEventListener('error', e => { msg.textContent = '‚ùå ' + (e.message || 'Script error'); });
</script>
</body>
</html>
