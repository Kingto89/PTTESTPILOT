<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>PT Lab ‚Äî Goniometry Trainer</title>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<style>
  html,body{margin:0;height:100%;background:#0b1220;color:#e5e7eb;overflow:hidden;font-family:system-ui,Segoe UI,Roboto}
  canvas{position:fixed; inset:0; z-index:0; width:100%; height:100%; display:block}

  .panel{position:fixed; left:0; top:0; bottom:0; width:340px; background:#0f172a; border-right:1px solid #1f2937; padding:14px; overflow:auto; z-index:50}
  #gonioHost{position:fixed; inset:0; z-index:30; pointer-events:none}
  #gonioHost svg{width:100vw;height:100vh;background:transparent;pointer-events:auto}
  .hud,.toast,#msg{z-index:40}
  .hud{position:fixed;top:10px;left:50%;transform:translateX(-50%);background:rgba(15,23,42,.75);border:1px solid #334155;border-radius:10px;padding:6px 10px;font-weight:700;backdrop-filter:blur(6px)}
  .toast{position:fixed;bottom:10px;left:50%;transform:translateX(-50%);background:rgba(2,6,23,.7);border:1px solid #334155;border-radius:10px;padding:6px 10px;font-size:13px;display:none}
  #msg{position:fixed;top:10px;left:10px;background:rgba(15,23,42,.7);border:1px solid #334155;border-radius:8px;padding:6px 10px;font-size:13px}

  h3{margin:8px 0 12px 0}
  label{display:block;font-size:13px;margin-top:10px;color:#cbd5e1}
  select,button,input[type=range]{width:100%;margin:6px 0 8px 0;padding:8px 10px;border-radius:10px;background:#1e293b;border:1px solid #334155;color:#e2e8f0}
  .row{display:flex;gap:8px}.row>button{flex:1}
  #log{background:#0b1220;border:1px solid #1f2937;height:130px;overflow:auto;border-radius:8px;padding:8px}
  .hide{display:none}.lockOn{background:#0b3a1f;border-color:#16a34a}

  /* Stacked pills */
  .pill{border:2px solid #334155;border-radius:12px;padding:6px 10px; display:flex; flex-direction:column; align-items:center; gap:3px}
  .pill .pillTop{font-weight:700; line-height:1}
  .pill .pillBottom{font-size:12px; opacity:.95; line-height:1}
  .pill.orange{border-color:#f59e0b}
  .pill.red{border-color:#ef4444}
  .pill.green{border-color:#22c55e}

  /* Note bubble */
  .note{position:fixed; right:16px; bottom:16px; width:min(520px, 90vw); background:rgba(2,6,23,.8); border:1px solid #334155; border-radius:12px; padding:12px; z-index:45; backdrop-filter: blur(6px)}
  .note h4{margin:0 0 4px 0}
  .note .x{position:absolute; right:8px; top:6px; cursor:pointer; border:0; background:transparent; color:#94a3b8; font-size:18px}
  .note .md *{margin:0 0 6px 0; line-height:1.35}
  .note .md ul{padding-left:18px}

  /* Controllers accordion (all collapsed by default) */
  .acc{margin-top:8px}
  .acc .hdr{width:100%; text-align:left; background:#0d162b; border:1px solid #334155; border-radius:10px; padding:10px; font-weight:600; display:flex; align-items:center; justify-content:space-between}
  .acc .hdr span{opacity:.8;font-weight:500;font-size:12px}
  .acc .body{display:none; padding:8px 6px 2px 6px}
  .acc.open .body{display:block}

  .sub{margin-top:8px; border:1px solid #22304a; border-radius:10px}
  .sub .subhdr{width:100%; text-align:left; background:#0c1426; border:0; border-bottom:1px solid #22304a; padding:8px 10px; border-radius:10px; font-weight:600}
  .sub .subbody{display:none; padding:8px 10px}
  .sub.open .subbody{display:block}
</style>
</head>
<body>
<div class="panel">
  <h3>Goniometry Trainer</h3>

  <label>Region</label>
  <select id="regionSel">
    <option value="cervical_spine">Cervical Spine</option>
    <option value="thoracic_lumbar_spine">Thoracic & Lumbar Spine</option>
    <option value="glenohumeral_joint">Glenohumeral Joint</option>
    <option value="elbow_radioulnar">Elbow & Radioulnar Joints</option>
    <option value="wrist">Wrist</option>
    <option value="hip">Hip</option>
    <option value="knee">Knee</option>
    <option value="talocrural_ankle">Talocrural (Ankle)</option>
    <option value="transverse_tarsal_subtalar">Transverse Tarsal & Subtalar</option>
    <option value="fingers_mcp_pip_dip">Fingers (MCP, PIP, DIP)</option>
    <option value="thumb_cmc_mcp_ip">Thumb (CMC, MCP, IP)</option>
    <option value="toes_mtp_pip_dip">Toes (MTP, PIP, DIP)</option>
  </select>

  <label>Motion</label>
  <select id="motionSel"></select>

  <div class="row">
    <button id="showNote">üìå Show goniometer placement</button>
  </div>

  <div class="row">
    <button class="pill orange" id="pickFulcrum"><span class="pillTop">üüß 1</span><span class="pillBottom">Fulcrum</span></button>
    <button class="pill red" id="pickStationary"><span class="pillTop">üü• 2</span><span class="pillBottom">Stationary</span></button>
    <button class="pill green" id="pickMoving"><span class="pillTop">üü© 3</span><span class="pillBottom">Moving</span></button>
  </div>

  <label>Options</label>
  <div class="row">
    <button id="toggleGhost">üëª Ghost Landmarks</button>
    <button id="resetAll">Reset</button>
  </div>

  <div class="row">
    <button id="measureToggle">üß≠ Measure: ON</button>
  </div>

  <label>Interaction Locks</label>
  <div class="row">
    <button id="lock3D">üîì 3D: Unlocked</button>
    <button id="lockGonio">üîì Gonio: Unlocked</button>
  </div>

  <!-- CONTROLLERS (collapsed by default) -->
  <div class="acc" id="acc-controllers">
    <button class="hdr" type="button"><div>Controllers</div><span id="focusHint">tap a section to focus</span></button>
    <div class="body">

      <div class="sub" id="sub-gonio">
        <button class="subhdr" type="button">Goniometer</button>
        <div class="subbody">
          <label>Gonio Size (10‚Äì200%)</label>
          <input type="range" min="10" max="200" step="5" value="100" id="gonioSize">
          <label>Rotate Moving Arm (¬∞)</label>
          <input type="range" min="0" max="360" step="1" value="30" id="rotateMove">
          <label>Rotate Goniometer (¬∞)</label>
          <input type="range" min="0" max="360" step="1" value="0" id="rotateGonio">
        </div>
      </div>

      <div class="sub" id="sub-model">
        <button class="subhdr" type="button">Model ‚Äî 1-finger: yaw ‚Ä¢ 2-finger: move ‚Ä¢ pinch: zoom</button>
        <div class="subbody">
          <label>Model Yaw (¬∞)</label>
          <input type="range" min="-180" max="180" step="1" value="0" id="modelYaw">
          <label>Model X (m)</label>
          <input type="range" min="-1" max="1" step="0.01" value="0" id="modelX">
          <label>Model Z (m)</label>
          <input type="range" min="-1" max="1" step="0.01" value="0" id="modelZ">
          <label>Model Y (m)</label>
          <input type="range" min="-0.5" max="0.5" step="0.01" value="0" id="modelY">
          <label>Model Zoom</label>
          <input type="range" min="50" max="200" step="1" value="100" id="modelScale">
        </div>
      </div>

      <div class="sub" id="sub-room">
        <button class="subhdr" type="button">Room ‚Äî drag X: yaw ‚Ä¢ drag Y: pitch</button>
        <div class="subbody">
          <label>Room Yaw (¬∞)</label>
          <input type="range" min="-180" max="180" step="1" value="10" id="roomYaw">
          <label>Room Pitch (¬∞)</label>
          <input type="range" min="-60" max="60" step="1" value="0" id="roomPitch">
        </div>
      </div>

    </div>
  </div>

  <label>Range of Motion</label>
  <div class="row">
    <button id="startROM">‚ñ∂Ô∏è Start ROM</button>
    <button id="resetROM">‚Ü∫ Reset ROM</button>
  </div>

  <label>Event Log</label>
  <pre id="log"></pre>
</div>

<!-- SVG goniometer -->
<div id="gonioHost" class="hide" aria-hidden="true">
  <svg id="gonioSvg" aria-label="Universal goniometer">
    <g id="viewport" transform="translate(0,0) scale(1)">
      <g id="rotWrap" transform="rotate(0)">
        <g id="mirrorWrap" transform="scale(1,1)">
          <g id="instrument">
            <g id="head">
              <circle r="120" fill="none" stroke="#94a3b8" stroke-width="1.6"/>
              <circle r="86"  fill="none" stroke="#94a3b8" stroke-width="0.9" opacity="0.65"/>
              <g id="ticks"></g>
              <g id="labelsFixed">
                <g id="numsOut"></g>
                <g id="numsInWrap"><g id="numsIn"></g></g>
              </g>
              <circle r="3.2" fill="#94a3b8"/>
            </g>

            <g id="armA_grp">
              <rect x="-10" y="120" width="20" height="260" rx="10" stroke="#ef4444" fill="none" stroke-width="3"/>
              <line id="axisA" x1="0" y1="380" x2="0" y2="-116" stroke="#ef4444" stroke-width="1.6" opacity=".85" stroke-linecap="round"/>
              <g id="armA_ruler"></g>
              <circle id="armA_knob" cx="0" cy="380" r="10" fill="#ef4444"/>
            </g>

            <g id="armB_grp">
              <rect x="-10" y="-380" width="20" height="500" rx="10" stroke="#22c55e" fill="none" stroke-width="3"/>
              <line id="axisB" x1="0" y1="-380" x2="0" y2="124" stroke="#22c55e" stroke-width="1.6" opacity=".85" stroke-linecap="round"/>
              <g id="armB_ruler"></g>
              <circle id="armB_knob" cx="0" cy="-380" r="10" fill="#22c55e"/>
              <circle id="armB_handleKnob" cx="0" cy="-380" r="38" fill="rgba(0,0,0,0)" style="pointer-events:all"/>
              <rect   id="armB_handleShaft" x="-20" y="-380" width="40" height="500" fill="rgba(0,0,0,0)" style="pointer-events:all"/>
            </g>
          </g>
        </g>
      </g>
    </g>
  </svg>
</div>

<div id="msg">Loading‚Ä¶</div>
<div class="hud" id="hud">Angle: 0¬∞</div>
<div class="toast" id="toast">Preset updated</div>
<canvas id="c"></canvas>

<!-- Note bubble -->
<div id="note" class="note hide">
  <button class="x" id="noteClose">‚úï</button>
  <h4 id="noteTitle">Note</h4>
  <div id="noteBody" class="md">Loading‚Ä¶</div>
</div>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";
import { KTX2Loader } from "three/addons/loaders/KTX2Loader.js";
import { MeshoptDecoder } from "three/addons/libs/meshopt_decoder.module.js";
import { EXRLoader } from "three/addons/loaders/EXRLoader.js";

/* ===== UI refs ===== */
const msg = document.getElementById("msg");
const hud = document.getElementById("hud");
const logEl = document.getElementById("log");
const toast = document.getElementById("toast");
const lock3DBtn = document.getElementById("lock3D");
const lockGonioBtn = document.getElementById("lockGonio");
const sizeEl = document.getElementById("gonioSize");
const rotateMoveEl = document.getElementById("rotateMove");
const rotateGonioEl = document.getElementById("rotateGonio");
const regionSel = document.getElementById("regionSel");
const motionSel = document.getElementById("motionSel");
const showNoteBtn = document.getElementById("showNote");
const focusHint = document.getElementById("focusHint");
const accCtrl = document.getElementById("acc-controllers");
const subG = document.getElementById("sub-gonio");
const subM = document.getElementById("sub-model");
const subR = document.getElementById("sub-room");
const log = (t)=>{ logEl.textContent += t + "\n"; logEl.scrollTop = logEl.scrollHeight; };

/* ===== Motions ===== */
const REGION_MOTIONS = {
  cervical_spine:["Flexion","Extension","Lateral Flexion","Rotation"],
  thoracic_lumbar_spine:["Flexion","Extension","Lateral Flexion","Rotation"],
  glenohumeral_joint:["Flexion","Extension","Abduction","Internal Rotation","External Rotation"],
  elbow_radioulnar:["Flexion","Extension","Pronation","Supination"],
  wrist:["Flexion","Extension","Radial Deviation","Ulnar Deviation"],
  hip:["Flexion","Extension","Abduction","Adduction","Internal Rotation","External Rotation"],
  knee:["Flexion","Extension"],
  talocrural_ankle:["Dorsiflexion","Plantarflexion"],
  transverse_tarsal_subtalar:["Inversion","Eversion"],
  fingers_mcp_pip_dip:["MCP Flexion","MCP Extension","PIP Flexion","PIP Extension","DIP Flexion","DIP Extension"],
  thumb_cmc_mcp_ip:["CMC Flexion","CMC Extension","CMC Abduction","CMC Adduction","MCP Flexion","MCP Extension","IP Flexion","IP Extension"],
  toes_mtp_pip_dip:["MTP Flexion","MTP Extension","PIP Flexion","PIP Extension","DIP Flexion","DIP Extension"]
};
function refreshMotions(){
  const list = REGION_MOTIONS?.[regionSel.value] || [];
  motionSel.innerHTML="";
  (list.length?list:["(No motions)"]).forEach(t=>{
    const o=document.createElement("option"); o.value=t==="(No motions)"?"":t; o.textContent=t; motionSel.appendChild(o);
  });
}
refreshMotions(); regionSel.onchange=refreshMotions;

/* ===== Three + Shadows ===== */
const canvas = document.getElementById("c");
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
renderer.setPixelRatio(devicePixelRatio);
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0b1220);

const camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 100);
camera.position.set(0.8,1.6,2.5);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.enabled = true;

/* HDRI background + env */
let backgroundSphere=null;
const pmremGen = new THREE.PMREMGenerator(renderer);
pmremGen.compileEquirectangularShader();
new EXRLoader().setPath("assets/").load("pt_evaluation_room.exr?v="+Date.now(), (exr)=>{
  const env=pmremGen.fromEquirectangular(exr);
  scene.environment=env.texture;
  const geo=new THREE.SphereGeometry(12,96,96);
  const mat=new THREE.MeshBasicMaterial({map:exr, side:THREE.BackSide});
  backgroundSphere=new THREE.Mesh(geo,mat);
  scene.add(backgroundSphere);
});

/* Lights (cast shadow) */
scene.add(new THREE.HemisphereLight(0xffffff,0x333344,0.9));
const dir = new THREE.DirectionalLight(0xffffff,1.1);
dir.position.set(4,6,2);
dir.castShadow = true;
dir.shadow.mapSize.set(2048,2048);
dir.shadow.camera.near=0.1; dir.shadow.camera.far=20;
scene.add(dir);

/* Model with feet pivot + shadow receiver plane */
const modelRoot=new THREE.Group(); scene.add(modelRoot);
const feetAnchor=new THREE.Group(); modelRoot.add(feetAnchor);

const shadowPlane=new THREE.Mesh(
  new THREE.CircleGeometry(0.38,48),
  new THREE.ShadowMaterial({opacity:0.35})
);
shadowPlane.rotation.x=-Math.PI/2;
shadowPlane.position.y=0; // ground at y=0
shadowPlane.receiveShadow=true;
modelRoot.add(shadowPlane);

let model=null;
const loader=new GLTFLoader();
loader.setMeshoptDecoder(MeshoptDecoder);
const draco=new DRACOLoader(); draco.setDecoderPath("https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/"); loader.setDRACOLoader(draco);
const ktx2=new KTX2Loader(); ktx2.setTranscoderPath("https://unpkg.com/three@0.160.0/examples/jsm/libs/basis/"); ktx2.detectSupport(renderer); loader.setKTX2Loader(ktx2);
const MODEL_URL="./Athletic_Grace_1006002620_texture.glb";

function putFeetOnGround(obj){
  const box=new THREE.Box3().setFromObject(obj);
  obj.position.sub(box.getCenter(new THREE.Vector3()));        // center
  obj.position.y -= -box.min.y;                                 // lift to y=0
}
function markCastShadow(obj){ obj.traverse?.(n=>{ if(n.isMesh){ n.castShadow=true; n.receiveShadow=false; } }); }

loader.load(MODEL_URL,(gltf)=>{
  model=gltf.scene;
  putFeetOnGround(model);
  markCastShadow(model);
  feetAnchor.add(model);
  msg.textContent="‚úÖ Model loaded";
}, undefined, ()=>{
  // fallback capsule
  const mat=new THREE.MeshStandardMaterial({color:0xa0a4ae, metalness:0.1, roughness:0.8});
  const g=new THREE.Mesh(new THREE.CapsuleGeometry(0.22,0.8,8,16), mat);
  markCastShadow(g);
  feetAnchor.add(g);
  model=g;
  msg.textContent="‚ö†Ô∏è GLB missing/blocked ‚Äî fallback mannequin shown";
});

/* ===== Gonio dots/lines & logic (same as prior) ===== */
const COLORS={stationary:0xef4444, moving:0x22c55e, fulcrum:0xf59e0b, ghost:0x38bdf8};
const dot=(c)=>new THREE.Mesh(new THREE.SphereGeometry(0.01,16,16), new THREE.MeshBasicMaterial({color:c}));
const user={fulcrum:dot(COLORS.fulcrum), stationary:dot(COLORS.stationary), moving:dot(COLORS.moving)};
Object.values(user).forEach(m=>{ m.visible=false; scene.add(m); });
const userLocal={fulcrum:null, stationary:null, moving:null};
const ghost={fulcrum:dot(COLORS.ghost), stationary:dot(COLORS.ghost), moving:dot(COLORS.ghost)};
Object.values(ghost).forEach(m=>{ m.visible=false; scene.add(m); });
let ghostOn=false; const updateGhost=()=>{ Object.entries(ghost).forEach(([k,m])=>{ if(userLocal[k]&&model){ m.position.copy(userLocal[k].clone().applyMatrix4(model.matrixWorld)); m.visible=ghostOn; } }); };

let target=null;
const ray=new THREE.Raycaster();
const mouse=new THREE.Vector2();
function toScreen(v3){ const v=v3.clone().project(camera); return {x:(v.x*0.5+0.5)*innerWidth, y:(-v.y*0.5+0.5)*innerHeight}; }
function placePoint(name, world){ if(!model) return; const local=model.worldToLocal(world.clone()); userLocal[name]=local; user[name].visible=true; user[name].position.copy(world); log(`${name} placed`); updateFromLocals(); }
canvas.addEventListener("pointerdown",(e)=>{
  if(!target||!model) return;
  const r=canvas.getBoundingClientRect();
  mouse.x=((e.clientX-r.left)/r.width)*2-1; mouse.y=-((e.clientY-r.top)/r.height)*2+1;
  ray.setFromCamera(mouse,camera);
  const hits=ray.intersectObjects(scene.children,true).filter(h=>!(h.object instanceof THREE.Line));
  if(!hits.length) return;
  placePoint(target,hits[0].point); target=null;
});
const line1=new THREE.Line(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({color:COLORS.stationary}));
const line2=new THREE.Line(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({color:COLORS.moving}));
scene.add(line1,line2);

/* ===== HUD / ROM ===== */
let romActive=false, romStartDeg=null;
function setAngleHUD(a,rom=""){ hud.textContent = rom?`Angle: ${a.toFixed(0)}¬∞ | ROM: ${rom}`:`Angle: ${a.toFixed(0)}¬∞`; }
function romString(){ if(!romActive||romStartDeg==null) return ""; const d=Math.abs(Gonio.angle-romStartDeg); return `${d.toFixed(0)}¬∞ (start ${romStartDeg.toFixed(0)}¬∞)`; }

/* ===== Align gonio to dots ===== */
function autoAlignGonioFromDots(f,s,m){
  const Fs=toScreen(f), Ss=toScreen(s), Ms=toScreen(m);
  const baseDeg=Gonio.degFromScreenVec(Ss.x-Fs.x,Ss.y-Fs.y);
  const movDeg =Gonio.degFromScreenVec(Ms.x-Fs.x,Ms.y-Fs.y);
  Gonio.show(); Gonio.setPose(Fs.x,Fs.y,baseDeg,movDeg);
  rotateGonioEl.value=Math.round(Gonio.getUserRot());
  rotateMoveEl.value=Math.round(Gonio.getMovDegAbs());
}
let followMeasure=true;
function updateFromLocals(){
  if(!model) return;
  ["fulcrum","stationary","moving"].forEach(k=>{ if(userLocal[k]){ user[k].position.copy(userLocal[k].clone()).applyMatrix4(model.matrixWorld); user[k].visible=true; }});
  const f=user.fulcrum.visible?user.fulcrum.position:null;
  const s=user.stationary.visible?user.stationary.position:null;
  const m=user.moving.visible?user.moving.position:null;

  line1.visible=!!(f&&s); line2.visible=!!(f&&m);
  if(line1.visible){ line1.geometry.dispose(); line1.geometry=new THREE.BufferGeometry().setFromPoints([f,s]); }
  if(line2.visible){ line2.geometry.dispose(); line2.geometry=new THREE.BufferGeometry().setFromPoints([f,m]); }
  if(f&&s&&m){ autoAlignGonioFromDots(f,s,m); if(followMeasure){ followMeasure=false; document.getElementById("measureToggle").textContent="üß≠ Measure: OFF"; } }
  else { Gonio.hide(); }
}

/* ===== Buttons ===== */
document.getElementById("pickFulcrum").onclick=()=>{ target="fulcrum"; log("Place Fulcrum"); };
document.getElementById("pickStationary").onclick=()=>{ target="stationary"; log("Place Stationary"); };
document.getElementById("pickMoving").onclick=()=>{ target="moving"; log("Place Moving"); };
document.getElementById("toggleGhost").onclick=()=>{ ghostOn=!ghostOn; updateGhost(); };
document.getElementById("resetAll").onclick=()=>{ Object.values(user).forEach(m=>m.visible=false); userLocal.fulcrum=userLocal.stationary=userLocal.moving=null; line1.visible=line2.visible=false; Gonio.hide(); setAngleHUD(0,""); romActive=false; romStartDeg=null; };
const measureToggle=document.getElementById("measureToggle");
measureToggle.onclick=()=>{ followMeasure=!followMeasure; measureToggle.textContent=followMeasure?"üß≠ Measure: ON":"üß≠ Measure: OFF"; };
document.getElementById("startROM").onclick=()=>{ romActive=true; romStartDeg=Gonio.angle; };
document.getElementById("resetROM").onclick=()=>{ romActive=false; romStartDeg=null; };

/* ===== Locks ===== */
let lock3D=false, lockGonio=false;
function set3DLock(v){ lock3D=v; controls.enabled=!lock3D; lock3DBtn.textContent=lock3D?"üîí 3D: Locked":"üîì 3D: Unlocked"; lock3DBtn.classList.toggle("lockOn",lock3D); }
function setGonioLock(v){ lockGonio=v; document.getElementById('instrument').style.pointerEvents=v?'none':'auto'; [sizeEl,rotateMoveEl,rotateGonioEl].forEach(el=>el.disabled=v); lockGonioBtn.textContent=v?"üîí Gonio: Locked":"üîì Gonio: Unlocked"; lockGonioBtn.classList.toggle("lockOn",v); }
set3DLock(false); setGonioLock(false);
lock3DBtn.onclick=()=>set3DLock(!lock3D);
lockGonioBtn.onclick=()=>setGonioLock(!lockGonio);

/* ===== Controllers: accordion + focus (all closed by default) ===== */
let focusMode/** @type {"model"|"room"|"gonio"|null} */ = null;
const toggle = (el)=> el.classList.toggle("open");
accCtrl.querySelector(".hdr").onclick=()=>toggle(accCtrl);
subG.querySelector(".subhdr").onclick=()=>{ toggle(subG); if(subG.classList.contains("open")){ [subM,subR].forEach(s=>s.classList.remove("open")); focusMode="gonio"; } else { focusMode=null; } focusHint.textContent = focusMode?`focused: ${focusMode}`:"tap a section to focus"; };
subM.querySelector(".subhdr").onclick=()=>{ toggle(subM); if(subM.classList.contains("open")){ [subG,subR].forEach(s=>s.classList.remove("open")); focusMode="model"; } else { focusMode=null; } focusHint.textContent = focusMode?`focused: ${focusMode}`:"tap a section to focus"; };
subR.querySelector(".subhdr").onclick=()=>{ toggle(subR); if(subR.classList.contains("open")){ [subG,subM].forEach(s=>s.classList.remove("open")); focusMode="room"; } else { focusMode=null; } focusHint.textContent = focusMode?`focused: ${focusMode}`:"tap a section to focus"; };

/* ===== Gonio sliders ===== */
sizeEl.oninput = ()=>{ if(lockGonio) return; Gonio.setScale(parseInt(sizeEl.value,10)/100); Gonio.refresh(); };
rotateMoveEl.oninput=()=>{ if(lockGonio) return; Gonio.setMovDegAbs(parseFloat(rotateMoveEl.value)); };
rotateGonioEl.oninput=()=>{ if(lockGonio) return; Gonio.setUserRot(parseFloat(rotateGonioEl.value)); };

/* ===== Model sliders ===== */
const modelYaw=document.getElementById("modelYaw");
const modelX=document.getElementById("modelX");
const modelZ=document.getElementById("modelZ");
const modelY=document.getElementById("modelY");
const modelScale=document.getElementById("modelScale");
function applyModel(){
  const s=parseFloat(modelScale.value)/100;
  feetAnchor.scale.setScalar(s);
  feetAnchor.rotation.y=THREE.MathUtils.degToRad(parseFloat(modelYaw.value));
  feetAnchor.position.set(parseFloat(modelX.value), parseFloat(modelY.value), parseFloat(modelZ.value));
}
[modelYaw,modelX,modelZ,modelY,modelScale].forEach(el=>el.addEventListener("input",applyModel));
applyModel();

/* ===== Room sliders ===== */
const roomYaw=document.getElementById("roomYaw");
const roomPitch=document.getElementById("roomPitch");
function applyRoom(){ if(!backgroundSphere) return; backgroundSphere.rotation.y=THREE.MathUtils.degToRad(parseFloat(roomYaw.value)); backgroundSphere.rotation.x=THREE.MathUtils.degToRad(parseFloat(roomPitch.value)); }
[roomYaw,roomPitch].forEach(el=>el.addEventListener("input",applyRoom));

/* ===== Gesture handling (only active when a section is open & focused) ===== */
const activePointers=new Map();
let lastMid=null,lastDist=null;
const midpoint=(a,b)=>({x:(a.x+b.x)/2,y:(a.y+b.y)/2});
const distance=(a,b)=>Math.hypot(a.x-b.x,a.y-b.y);

renderer.domElement.addEventListener("pointerdown",(e)=>{ if(lock3D) return; renderer.domElement.setPointerCapture(e.pointerId); activePointers.set(e.pointerId,{x:e.clientX,y:e.clientY}); lastMid=null; lastDist=null; });
renderer.domElement.addEventListener("pointermove",(e)=>{
  if(lock3D) return;
  if(!activePointers.has(e.pointerId)) return;
  activePointers.set(e.pointerId,{x:e.clientX,y:e.clientY});

  if(focusMode==="model"){
    const pts=[...activePointers.values()];
    if(pts.length===1){ modelYaw.value=String(THREE.MathUtils.clamp(parseFloat(modelYaw.value)+e.movementX*0.25,-180,180)); applyModel(); }
    else if(pts.length>=2){ const [a,b]=pts; const mid=midpoint(a,b); const dist=distance(a,b); if(lastMid){ const k=0.002; modelX.value=String(THREE.MathUtils.clamp(parseFloat(modelX.value)+(mid.x-lastMid.x)*k,-1,1)); modelZ.value=String(THREE.MathUtils.clamp(parseFloat(modelZ.value)+(mid.y-lastMid.y)*k,-1,1)); } if(lastDist){ modelScale.value=String(THREE.MathUtils.clamp(parseFloat(modelScale.value)+(dist-lastDist)*0.15,50,200)); } lastMid=mid; lastDist=dist; applyModel(); }
  } else if(focusMode==="room"){
    roomYaw.value = String(THREE.MathUtils.clamp(parseFloat(roomYaw.value)+e.movementX*0.25,-180,180));
    roomPitch.value = String(THREE.MathUtils.clamp(parseFloat(roomPitch.value)-e.movementY*0.15,-60,60));
    applyRoom();
  }
});
renderer.domElement.addEventListener("pointerup",(e)=>{ activePointers.delete(e.pointerId); lastMid=null; lastDist=null; });
renderer.domElement.addEventListener("pointercancel",(e)=>{ activePointers.delete(e.pointerId); lastMid=null; lastDist=null; });

renderer.domElement.addEventListener("wheel",(e)=>{
  if(lock3D) return;
  if(focusMode==="model"){ modelScale.value=String(THREE.MathUtils.clamp(parseFloat(modelScale.value)+(e.deltaY<0?3:-3),50,200)); applyModel(); }
  else if(focusMode==="room"){ roomYaw.value=String(THREE.MathUtils.clamp(parseFloat(roomYaw.value)+(e.deltaY<0?3:-3),-180,180)); applyRoom(); }
},{passive:true});

/* ===== Toast & render loop ===== */
function showToast(){ toast.style.display='block'; clearTimeout(showToast.tid); showToast.tid=setTimeout(()=>toast.style.display='none',1200); }
addEventListener("resize", ()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); Gonio._clampNow?.(); });
const clock=new THREE.Clock();
(function animate(){
  clock.getDelta(); controls.update();
  if(followMeasure) updateFromLocals();
  if(!document.getElementById('gonioHost').classList.contains('hide')) setAngleHUD(Gonio.angle, romString());
  renderer.render(scene,camera);
  requestAnimationFrame(animate);
})();

/* ===== Goniometer module (unchanged except small guards) ===== */
const Gonio=(()=>{
  const host=document.getElementById('gonioHost');
  const svg=document.getElementById('gonioSvg');
  const viewport=document.getElementById('viewport');
  const rotWrap=document.getElementById('rotWrap');
  const numsInWrap=document.getElementById('numsInWrap');
  const labelsFixed=document.getElementById('labelsFixed');

  const clamp=(v,a,b)=>Math.min(b,Math.max(a,v));
  const clamp360=a=>(a%360+360)%360;
  const toDegUp=(x,y)=>clamp360(Math.atan2(-y,x)*180/Math.PI+90);

  (function build(){
    const ticks=document.getElementById('ticks');
    const numsOut=document.getElementById('numsOut');
    const numsIn=document.getElementById('numsIn');
    const R=120, Rin=86;
    const line=(p,x1,y1,x2,y2,cls)=>{const n=document.createElementNS('http://www.w3.org/2000/svg','line'); n.setAttribute('x1',x1); n.setAttribute('y1',y1); n.setAttribute('x2',x2); n.setAttribute('y2',y2); if(cls) n.setAttribute('class',cls); p.appendChild(n);};
    const text=(p,x,y,t,cls)=>{const n=document.createElementNS('http://www.w3.org/2000/svg','text'); n.setAttribute('x',x); n.setAttribute('y',y); n.setAttribute('class',cls||'labelOuter'); n.textContent=t; p.appendChild(n); return n;};
    for(let d=0; d<360; d+=5){ const a=(d-90)*Math.PI/180, big=d%30===0, len=big?12:6; line(ticks,Math.cos(a)*(R-len),Math.sin(a)*(R-len),Math.cos(a)*R,Math.sin(a)*R,big?'tick tickBig':'tick'); }
    const rWhite=R-8;
    for(let d=0; d<360; d+=10){ const diff90=Math.abs(((d-90)%360+540)%360-180); const diff270=Math.abs(((d-270)%360+540)%360-180); const val=Math.min(diff90,diff270); if(val%20===0 && val<=80){ const a=(d-90)*Math.PI/180,x=Math.cos(a)*rWhite,y=Math.sin(a)*rWhite; text(numsOut,x,y,String(val),'labelOuter'); } }
    const rInner=Rin+9, valFromTheta=th=>{const t=(th+180)%360; return t<=180?t:360-t;};
    for(let th=0; th<360; th+=10){ const v=valFromTheta(th); if(v%10!==0) continue; if(v===0 && th!==180) continue; const a=(th-90)*Math.PI/180,x=Math.cos(a)*rInner,y=Math.sin(a)*rInner; text(numsIn,x,y,String(v),'labelInner'); }
  })();

  let mov=30, zoom=1, panX=innerWidth/2, panY=innerHeight/2;
  let baseRot=0, userRot=0, scale=1;
  let draggingArm=false, draggingPan=false, lastPanScreen=null;

  function applyView(){ viewport.setAttribute('transform',`translate(${panX},${panY}) scale(${zoom*scale})`); }
  function applyRot(){ rotWrap.setAttribute('transform',`rotate(${baseRot+userRot})`); }
  function applyLabelFix(){ const t=-(baseRot+userRot); labelsFixed.setAttribute('transform',`rotate(${t})`); numsInWrap.setAttribute('transform',`rotate(${-t})`); }

  function clampPan(){ const bound=140*zoom*scale, m=150; const minX=m+bound, maxX=innerWidth-m-bound; const minY=m+bound, maxY=innerHeight-m-bound; if(minX<=maxX) panX=Math.min(maxX,Math.max(minX,panX)); else panX=innerWidth/2; if(minY<=maxY) panY=Math.min(maxY,Math.max(minY,panY)); else panY=innerHeight/2; }
  function render(){ document.getElementById('armA_grp').setAttribute('transform','rotate(0)'); document.getElementById('armB_grp').setAttribute('transform',`rotate(${mov})`); }
  clampPan(); applyView(); applyRot(); applyLabelFix(); render();

  svg.addEventListener('pointerdown',e=>{ if(lockGonio) return; if(e.target.closest('#armB_grp')) return; e.preventDefault(); draggingPan=true; lastPanScreen={x:e.clientX,y:e.clientY}; svg.setPointerCapture?.(e.pointerId); });
  svg.addEventListener('pointermove',e=>{ if(lockGonio) return; if(!draggingPan||!lastPanScreen) return; const dx=(e.clientX-lastPanScreen.x)/(zoom*scale); const dy=(e.clientY-lastPanScreen.y)/(zoom*scale); panX+=dx; panY+=dy; lastPanScreen={x:e.clientX,y:e.clientY}; clampPan(); applyView(); });
  svg.addEventListener('pointerup',()=>{ draggingPan=false; lastPanScreen=null; });
  svg.addEventListener('pointercancel',()=>{ draggingPan=false; lastPanScreen=null; });
  svg.addEventListener('wheel',e=>{ if(lockGonio) return; e.preventDefault(); const step=Math.sign(e.deltaY)<0?1.22:1/1.22; zoom=THREE.MathUtils.clamp(zoom*step,0.07,10); clampPan(); applyView(); },{passive:false});

  function startArm(e){ if(lockGonio) return; e.stopPropagation(); e.preventDefault(); document.getElementById('armB_grp').setPointerCapture?.(e.pointerId); draggingArm=true; }
  function moveArm(e){ if(lockGonio) return; if(!draggingArm) return; e.stopPropagation(); e.preventDefault(); const pt=svg.createSVGPoint(); pt.x=e.clientX; pt.y=e.clientY; const p=pt.matrixTransform(rotWrap.getScreenCTM().inverse()); mov=(Math.atan2(-p.y,p.x)*180/Math.PI+90+360)%360; render(); }
  function endArm(){ draggingArm=false; }
  ['armB_handleKnob','armB_handleShaft','armB_grp','armB_knob'].forEach(id=>{ const el=document.getElementById(id); if(!el) return; el.addEventListener('pointerdown',startArm); el.addEventListener('pointermove',moveArm); el.addEventListener('pointerup',endArm); el.addEventListener('pointercancel',endArm); });

  function show(){ host.classList.remove('hide'); host.setAttribute('aria-hidden','false'); clampPan(); applyView(); }
  function hide(){ host.classList.add('hide'); host.setAttribute('aria-hidden','true'); }
  function setPose(cx,cy,baseDeg,movDeg){ panX=cx; panY=cy; baseRot=baseDeg; mov=(movDeg-baseDeg+360)%360; clampPan(); applyView(); applyRot(); applyLabelFix(); render(); }
  function setScale(k){ scale=THREE.MathUtils.clamp(k||1,0.1,2); clampPan(); applyView(); }
  function setMovDegAbs(deg){ mov=(deg%360+360)%360; render(); }
  function setUserRot(deg){ userRot=(deg%360+360)%360; applyRot(); applyLabelFix(); render(); }
  function getUserRot(){ return (userRot%360+360)%360; }
  function getMovDegAbs(){ return (mov%360+360)%360; }
  function angle(){ const a=(mov%360+360)%360; return a>180?360-a:a; }

  return { show, hide, setPose, setScale, setMovDegAbs, setUserRot, getUserRot, getMovDegAbs,
    get angle(){ return angle(); },
    degFromScreenVec:(dx,dy)=>((Math.atan2(-dy,dx)*180/Math.PI+90+360)%360),
    _clampNow:()=>{clampPan();applyView();}, refresh:()=>{applyView();applyRot();applyLabelFix();render();} };
})();
window.Gonio=Gonio;

/* ===== Notes loader ===== */
const note=document.getElementById("note");
const noteTitle=document.getElementById("noteTitle");
const noteBody=document.getElementById("noteBody");
document.getElementById("noteClose").onclick=()=>note.classList.add("hide");
function mdToHtml(md){ let html=md.replace(/^### (.*)$/gm,'<h5>$1</h5>').replace(/^## (.*)$/gm,'<h4>$1</h4>').replace(/^# (.*)$/gm,'<h3>$1</h3>').replace(/^\* (.*)$/gm,'<li>$1</li>'); html=html.replace(/(<li>[\s\S]*?<\/li>)/g,'<ul>$1</ul>'); html=html.replace(/\*\*(.*?)\*\*/g,'<strong>$1</strong>'); return html; }
function regionToTitle(r){ return ({cervical_spine:"Cervical Spine", thoracic_lumbar_spine:"Thoracic & Lumbar Spine", glenohumeral_joint:"Glenohumeral Joint", elbow_radioulnar:"Elbow & Radioulnar Joints", wrist:"Wrist", hip:"Hip", knee:"Knee", talocrural_ankle:"Talocrural (Ankle)", transverse_tarsal_subtalar:"Transverse Tarsal & Subtalar", fingers_mcp_pip_dip:"Fingers (MCP, PIP, DIP)", thumb_cmc_mcp_ip:"Thumb (CMC, MCP, IP)", toes_mtp_pip_dip:"Toes (MTP, PIP, DIP)"}[r]||r.replace(/_/g,' ')); }
async function loadNote(region,motion){ const url=`content/goniometry/${region}.md?${Date.now()}`; try{ const res=await fetch(url); if(!res.ok) throw new Error(res.status); const md=await res.text(); const re=new RegExp(`(^|\\n)##?\\s*${motion}\\s*\\n([\\s\\S]*?)(\\n##?\\s|$)`,'i'); const m=motion?md.match(re):null; const section=m?m[2].trim():md; noteTitle.textContent=`${regionToTitle(region)} ‚Äî ${motion||"General"}`; noteBody.innerHTML=mdToHtml(section||"‚Äî"); }catch{ noteTitle.textContent=`${regionToTitle(region)} ‚Äî ${motion||"General"}`; noteBody.textContent="Failed to load note."; } }
showNoteBtn.onclick=async()=>{ await loadNote(regionSel.value, motionSel.value||"(General)"); note.classList.remove("hide"); };

/* ===== Errors ===== */
window.addEventListener('error', e=>{ msg.textContent='‚ùå '+(e.message||'Script error'); console.error(e); });
</script>
</body>
</html>
