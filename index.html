<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Goniometer Integration ‚Äì Fixed</title>
<style>
  html,body{margin:0;height:100%;overflow:hidden;background:#0b0f14;color:#e5e7eb;font:14px/1.3 system-ui,Segoe UI,Roboto,Helvetica,Arial}
  #app{position:fixed;inset:0;display:grid;grid-template-columns:280px 1fr}
  #sidebar{background:#0f172a;padding:12px 12px 16px;border-right:1px solid #1f2937;overflow:auto}
  #sidebar h2{font-size:16px;margin:0 0 8px}
  #sidebar .row{display:flex;align-items:center;gap:8px;margin:8px 0}
  #sidebar button,#sidebar input[type="range"]{width:100%}
  #viewport{position:relative;background:#0b0f14}
  canvas.webgl{position:absolute;inset:0;display:block}
  /* Goniometer overlay (SVG) */
  #gonioHost{position:absolute;left:50%;top:50%;translate:-50% -50%;touch-action:none;user-select:none}
  #gonioHost.hide{display:none}
  #gonioSvg{width:420px;height:420px}
  .arm{cursor:grab}
  .arm:active{cursor:grabbing}
  .tick{pointer-events:none;opacity:.9}
  .ruler text{font-size:10px;fill:#94a3b8}
  /* Angle readout badge */
  #angleBadge{position:absolute;left:50%;top:50%;translate:-50% calc(-50% - 140px);padding:6px 10px;background:#111827;border:1px solid #374151;border-radius:10px;font-weight:600}
  /* Labels around ring */
  .ringLabel{position:absolute;pointer-events:none;color:#94a3b8;font-size:12px}
  .pill{display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border:1px solid #374151;border-radius:999px;background:#0b1220}
  .muted{color:#9ca3af}
  .fine{font-size:12px;color:#9ca3af}
</style>
</head>
<body>
<div id="app">
  <aside id="sidebar">
    <h2>Goniometer Controls</h2>
    <div class="row">
      <button id="btnMeasure" class="pill" aria-pressed="true">üß≠ Measure: <span id="measureVal">ON</span></button>
    </div>
    <div class="row">
      <button id="btnLock" class="pill" aria-pressed="false">üîì Gonio: <span id="lockVal">Unlocked</span></button>
    </div>
    <div class="row">
      <label class="muted" style="width:90px">Gonio Size</label>
      <input id="scale" type="range" min="10" max="200" step="1" value="100" />
    </div>
    <div class="row fine">Tip: Turn <b>Measure OFF</b> for full manual control.</div>
  </aside>
  <main id="viewport" aria-live="polite" aria-busy="false">
    <div id="angleBadge">ROM: <span id="angleVal">0</span>¬∞</div>
    <div id="gonioHost">
      <!-- SVG goniometer -->
      <svg id="gonioSvg" viewBox="0 0 400 400">
        <defs>
          <marker id="arrow" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="4" markerHeight="4" orient="auto-start-reverse">
            <path d="M 0 0 L 10 5 L 0 10 z" fill="#e11d48"></path>
          </marker>
        </defs>

        <!-- ring + ticks -->
        <g id="ring" transform="translate(200,200)">
          <circle cx="0" cy="0" r="150" fill="none" stroke="#334155" stroke-width="2"/>
          <!-- 30¬∞ ticks -->
          <g class="tick">
            <g id="ticks30"></g>
          </g>
          <!-- 5¬∞ minor ticks -->
          <g class="tick" id="ticks5" opacity=".6"></g>
        </g>

        <!-- base (red) arm -->
        <g id="armBase" class="arm" transform="translate(200,200) rotate(0)">
          <line x1="0" y1="0" x2="0" y2="-150" stroke="#ef4444" stroke-width="6" stroke-linecap="round"></line>
          <circle cx="0" cy="0" r="10" fill="#ef4444"></circle>
        </g>

        <!-- moving (green) arm -->
        <g id="armMove" class="arm" transform="translate(200,200) rotate(30)">
          <line x1="0" y1="0" x2="0" y2="-150" stroke="#22c55e" stroke-width="6" stroke-linecap="round" marker-end="url(#arrow)"></line>
          <circle cx="0" cy="0" r="10" fill="#22c55e"></circle>
        </g>

        <!-- simple inch/cm rulers along arms (labels only) -->
        <g class="ruler" transform="translate(200,200)">
          <text x="-8" y="-130">5 cm</text>
          <text x="-8" y="-100">4</text>
          <text x="-8" y="-70">3</text>
          <text x="-8" y="-40">2</text>
          <text x="-8" y="-10">1</text>
          <text x="-8" y="15">0</text>
        </g>
      </svg>
    </div>
  </main>
</div>

<!-- three.js (model/scene placeholder). Keep if you show a 3D limb; remove if not needed. -->
<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js"></script>

<script>
/* =========================
   Scene (placeholder)
   ========================= */
const vp = document.getElementById('viewport');
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(50, vp.clientWidth/vp.clientHeight, 0.1, 1000);
camera.position.set(0,2.2,3.5);
const renderer = new THREE.WebGLRenderer({antialias:true,alpha:true});
renderer.setPixelRatio(devicePixelRatio);
renderer.setSize(vp.clientWidth, vp.clientHeight);
renderer.domElement.classList.add('webgl');
vp.appendChild(renderer.domElement);
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

window.addEventListener('resize', ()=>{
  camera.aspect = vp.clientWidth/vp.clientHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(vp.clientWidth, vp.clientHeight);
  Gonio._clampNow && Gonio._clampNow();
  layoutLabels();
});

/* =========================
   Goniometer module
   ========================= */
const Gonio = (function(){
  const host = document.getElementById('gonioHost');
  const svg  = document.getElementById('gonioSvg');
  const armBase = document.getElementById('armBase');
  const armMove = document.getElementById('armMove');
  const ring = document.getElementById('ring');
  const ticks30 = document.getElementById('ticks30');
  const ticks5  = document.getElementById('ticks5');
  const angleEl = document.getElementById('angleVal');
  const badgeEl = document.getElementById('angleBadge');

  // Build tick labels
  function addTicks(){
    // every 30¬∞
    for(let d=0; d<360; d+=30){
      const g = document.createElementNS("http://www.w3.org/2000/svg","g");
      g.setAttribute("transform", `rotate(${d})`);
      const l = (d%90===0)?16:12;
      g.innerHTML = `<line x1="0" y1="-150" x2="0" y2="${-150+l}" stroke="#64748b" stroke-width="2" />
                     <text x="-8" y="${-150-l-6}" fill="#94a3b8" font-size="10">${d===0?'0':d}</text>`;
      ticks30.appendChild(g);
    }
    // minor every 5¬∞
    for(let d=5; d<360; d+=5){
      if (d%30===0) continue;
      const g = document.createElementNS("http://www.w3.org/2000/svg","g");
      g.setAttribute("transform", `rotate(${d})`);
      g.innerHTML = `<line x1="0" y1="-150" x2="0" y2="-144" stroke="#475569" stroke-width="1.5" />`;
      ticks5.appendChild(g);
    }
  }
  addTicks();

  let panX = 200, panY = 200;      // svg coords
  let scale = 1.0;                 // 0.1‚Äì2.0
  let baseDeg = 0;                 // red arm
  let moveDeg = 30;                // green arm
  let draggingArm = null;          // 'base' | 'move' | null
  let draggingView = false;        // drag ring to pan
  let locked = false;

  // Helpers
  const toDegUp = (dx,dy)=> ( (Math.atan2(dx, -dy) * 180/Math.PI) + 360 ) % 360;
  function applyView(){
    svg.style.width  = `${420*scale}px`;
    svg.style.height = `${420*scale}px`;
    // host is centered, so offset using translate
    host.style.left = panX+'px';
    host.style.top  = panY+'px';
  }
  function applyRot(){
    armBase.setAttribute('transform', `translate(200,200) rotate(${baseDeg})`);
    armMove.setAttribute('transform', `translate(200,200) rotate(${moveDeg})`);
  }
  function clampPan(){
    const pad = 20;
    const w = vp.clientWidth, h = vp.clientHeight;
    const sw = 420*scale, sh = 420*scale;
    // keep at least part visible
    panX = Math.min(w - pad, Math.max(pad, panX));
    panY = Math.min(h - pad, Math.max(pad, panY));
  }
  function currentAngle(){
    // minimal difference 0..180 for ROM
    const raw = ( (moveDeg - baseDeg) % 360 + 360 ) % 360;
    return raw > 180 ? 360 - raw : raw;
  }
  function updateBadge(){
    angleEl.textContent = Math.round(currentAngle());
  }

  // Public surface
  function show(){ host.classList.remove('hide'); host.setAttribute('aria-hidden','false'); }
  function hide(){ host.classList.add('hide'); host.setAttribute('aria-hidden','true'); }
  function setPose(cx,cy,base,move){
    panX=cx; panY=cy; baseDeg=base; moveDeg=move;
    clampPan(); applyView(); applyRot(); updateBadge();
  }
  function setScale(k){ scale=Math.min(2,Math.max(0.1,k||1)); clampPan(); applyView(); }
  function degFromScreenVec(dx,dy){ return toDegUp(dx,dy); }

  // Pointer interactions
  function onArmPointerDown(which, e){
    if (locked) return;
    draggingArm = which;
    (e.target.ownerSVGElement || e.target).setPointerCapture(e.pointerId);
  }
  function onArmPointerMove(which, e){
    if (draggingArm !== which) return;
    // vector from center (200,200) to pointer in SVG coords
    const pt = svg.createSVGPoint();
    pt.x = e.clientX - (host.getBoundingClientRect().left);
    pt.y = e.clientY - (host.getBoundingClientRect().top);
    // convert to internal (account for scale and center)
    const bx = (pt.x - (svg.clientWidth/2));
    const by = (pt.y - (svg.clientHeight/2));
    const deg = toDegUp(bx,by);
    if (which === 'base') baseDeg = deg;
    else moveDeg = deg;
    applyRot();
    updateBadge(); // ‚Üê keep ROM live while dragging
  }
  function onArmPointerUp(which, e){
    if (draggingArm === which) draggingArm = null;
  }

  armBase.addEventListener('pointerdown', onArmPointerDown.bind(null,'base'));
  armBase.addEventListener('pointermove', onArmPointerMove.bind(null,'base'));
  armBase.addEventListener('pointerup',   onArmPointerUp.bind(null,'base'));
  armBase.addEventListener('pointercancel',onArmPointerUp.bind(null,'base'));

  armMove.addEventListener('pointerdown', onArmPointerDown.bind(null,'move'));
  armMove.addEventListener('pointermove', onArmPointerMove.bind(null,'move'));
  armMove.addEventListener('pointerup',   onArmPointerUp.bind(null,'move'));
  armMove.addEventListener('pointercancel',onArmPointerUp.bind(null,'move'));

  // Pan the whole gonio by dragging the empty ring area
  ring.addEventListener('pointerdown', e=>{
    if (locked) return;
    draggingView = true;
    ring.setPointerCapture(e.pointerId);
    ring.dataset.startX = e.clientX;
    ring.dataset.startY = e.clientY;
    ring.dataset.panX = panX;
    ring.dataset.panY = panY;
  });
  ring.addEventListener('pointermove', e=>{
    if (!draggingView) return;
    const sx = +ring.dataset.startX, sy = +ring.dataset.startY;
    const px = +ring.dataset.panX,  py = +ring.dataset.panY;
    panX = px + (e.clientX - sx);
    panY = py + (e.clientY - sy);
    clampPan(); applyView();
  });
  ring.addEventListener('pointerup', ()=> draggingView=false);
  ring.addEventListener('pointercancel', ()=> draggingView=false);

  // Init
  setPose(panX,panY,baseDeg,moveDeg);

  // Expose drag state so the app loop can pause landmark-sync while dragging
  return {
    show, hide, setPose, setScale, degFromScreenVec,
    _clampNow: clampPan,
    isDragging: () => !!draggingArm,
    setLocked: (v)=>{ locked = !!v; },
    get angle(){ return currentAngle(); },
    refresh: ()=>{ applyView(); applyRot(); updateBadge(); }
  };
})();
window.Gonio = Gonio;

/* =========================
   Landmark / measure logic
   ========================= */
let followMeasure = true; // when ON, arms snap to landmarks (not shown; wire yours if needed)

// Example stub that would read your 3 dots and update pose.
// Replace with your real updateFromLocals() that computes baseDeg/moveDeg from landmarks.
function updateFromLocals(){
  // --- example: no-op; your real code sets baseDeg/moveDeg & calls Gonio.refresh()
  // Gonio.setPose(cx, cy, baseDeg, moveDeg);
}

/* =========================
   UI wiring
   ========================= */
const btnMeasure = document.getElementById('btnMeasure');
const measureVal = document.getElementById('measureVal');
btnMeasure.addEventListener('click', ()=>{
  followMeasure = !followMeasure;
  measureVal.textContent = followMeasure ? 'ON' : 'OFF';
  btnMeasure.setAttribute('aria-pressed', String(followMeasure));
});

const btnLock = document.getElementById('btnLock');
const lockVal = document.getElementById('lockVal');
btnLock.addEventListener('click', ()=>{
  const next = lockVal.textContent === 'Unlocked' ? 'Locked' : 'Unlocked';
  lockVal.textContent = next;
  btnLock.setAttribute('aria-pressed', String(next==='Locked'));
  Gonio.setLocked(next==='Locked');
});

document.getElementById('scale').addEventListener('input', e=>{
  Gonio.setScale(+e.target.value/100);
  Gonio.refresh();
});

/* =========================
   Angle labels around ring (UI-only, not required)
   ========================= */
const labels=[];
function makeLabel(text){
  const div=document.createElement('div');
  div.className='ringLabel';
  div.textContent=text;
  document.body.appendChild(div);
  return div;
}
for (let d=0; d<360; d+=30) labels.push({deg:d, el:makeLabel(`${d}¬∞`)});
const tmpV = new THREE.Vector3();
function layoutLabels(){
  // Place labels roughly where the ring sits (simple center projection)
  const rect = document.getElementById('gonioHost').getBoundingClientRect();
  const cx = rect.left + rect.width/2;
  const cy = rect.top  + rect.height/2;
  const R = (rect.width/2) - 20;
  labels.forEach(({deg,el})=>{
    const a=THREE.MathUtils.degToRad(deg);
    const x=cx + Math.cos(a)*R, y=cy + Math.sin(a)*R;
    el.style.left = `${x-10}px`; el.style.top = `${y-8}px`;
  });
}

/* =========================
   Main loop
   ========================= */
function animate(){
  controls.update();

  // Only auto-sync to landmarks if user is NOT dragging an arm
  if (followMeasure && !(Gonio && Gonio.isDragging && Gonio.isDragging())) {
    updateFromLocals(); // your function that sets pose from 3 dots
  }

  // Keep ROM readout fresh even during manual drag
  document.getElementById('angleVal').textContent = Math.round(Gonio.angle);

  renderer.render(scene, camera);
  layoutLabels();
  requestAnimationFrame(animate);
}
animate();
</script>
</body>
</html>
