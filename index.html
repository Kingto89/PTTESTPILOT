<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta content="width=device-width, initial-scale=1" name="viewport">
<title>Index 48</title>
<style>
/* copied from your index (48).html */
html, body {
  margin: 0;
  padding: 0;
}
canvas {
  display: block;
  outline: none;
}
/* original index (48) UI styles if present (kept intact) */
#panel{
  position: fixed;
  top: 10px; left: 10px;
  background: rgba(255,255,255,0.92);
  border: 1px solid #bbb;
  border-radius: 10px;
  padding: 10px;
  z-index: 1000;
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  font-size: 14px;
}
button, .btn {
  padding: 6px 10px;
  border-radius: 6px;
  border: 1px solid #aaa;
  background: #fff;
  cursor: pointer;
}
.btn-row { display:flex; gap: 6px; flex-wrap: wrap; }
.dot{
  position: absolute;
  width: 12px; height: 12px; border-radius: 50%;
  border: 2px solid #000; background: #ffe000;
  box-shadow: 0 0 0 1px #000;
}
/* --- your page content continues… (kept as-is) --- */
</style>
</head>
<body>

<!-- Your original scene root (kept) -->
<canvas id="sceneCanvas"></canvas>

<!-- Optional: your UI panel (kept as-is, if it existed) -->
<div id="panel" role="region" aria-label="Controls">
  <div class="btn-row">
    <button id="measureOn">Measure: ON</button>
    <button id="measureOff">Measure: OFF</button>
    <button id="reset">Reset</button>
  </div>
  <div style="font-size:12px;color:#444;margin-top:6px;">Click three points in order: fulcrum → stationary → moving</div>
</div>

<!-- Example landmark dots (replace/remove if you already place your own) -->
<!-- If your page already creates dots, ensure they have ids or data-role attributes as below -->
<div id="dot-fulcrum" class="dot" style="left: 50vw; top: 40vh;"></div>
<div id="dot-stationary" class="dot" style="left: calc(50vw + 140px); top: 40vh;"></div>
<div id="dot-moving" class="dot" style="left: calc(50vw + 40px); top: calc(40vh + 140px);"></div>

<!-- ====== GONIOMETER OVERLAY (inline, no background) ====== -->
<style>
  #gonioOverlay {
    position: fixed; inset: 0;
    pointer-events: none; /* clicks pass through */
    background: transparent;
    z-index: 999999; /* on top of everything */
  }
  #gonioUI {
    position: absolute; left: 0; top: 0;
    width: 0; height: 0;
    transform: translate(var(--gx, 0px), var(--gy, 0px)) rotate(var(--grot, 0deg));
    transform-origin: 0 0;
  }
  /* Inline SVG goniometer built here for reliable control */
  #gonioSVG {
    overflow: visible;
  }
  .arm { transform-origin: 0px 0px; }
  .arm line { stroke-width: 6; }
  .tick { stroke-width: 1; }
  .label { font-family: system-ui, sans-serif; font-size: 11px; user-select: none; }
  /* Simple controller button (top-right) */
  #gonioToggle {
    position: fixed; top: 10px; right: 10px;
    pointer-events: auto;
    z-index: 1000000;
    padding: 8px 12px; border-radius: 10px; border: 1px solid #aaa;
    background: rgba(255,255,255,0.9);
    font-family: system-ui, sans-serif; font-size: 14px; cursor: pointer;
  }
</style>

<div id="gonioOverlay" hidden>
  <div id="gonioUI">
    <svg id="gonioSVG" width="800" height="800" viewBox="-400 -400 800 800">
      <!-- Protractor circle -->
      <circle r="200" fill="none" stroke="#222" stroke-width="2"></circle>
      <!-- Degree ticks (every 10) with centered zero between red 10s -->
      <g id="ticks"></g>
      <text class="label" text-anchor="middle" y="-220">0</text>

      <!-- Stationary arm (red) baseline -->
      <g id="armStationary" class="arm">
        <line x1="0" y1="0" x2="220" y2="0" stroke="red"></line>
      </g>

      <!-- Moving arm (green) -->
      <g id="armMoving" class="arm">
        <line x1="0" y1="0" x2="220" y2="0" stroke="green"></line>
      </g>

      <!-- Ladder rungs along moving arm (alternating red/black when head-clicked) -->
      <g id="ladder"></g>

      <!-- Center dot -->
      <circle r="4" fill="#000"></circle>
    </svg>
  </div>
</div>

<button id="gonioToggle" type="button" aria-pressed="false">Goniometer</button>

<script>
(function(){
  const overlay = document.getElementById('gonioOverlay');
  const ui = document.getElementById('gonioUI');
  const btn = document.getElementById('gonioToggle');
  const armS = document.getElementById('armStationary');
  const armM = document.getElementById('armMoving');
  const ladder = document.getElementById('ladder');
  const ticks = document.getElementById('ticks');

  // Build 10-degree ticks with red '10s' and centered zero
  for (let a=0; a<360; a+=10) {
    const rad = a*Math.PI/180;
    const x1 = Math.cos(rad)*200, y1 = Math.sin(rad)*200;
    const x2 = Math.cos(rad)*188, y2 = Math.sin(rad)*188;
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    const ln = document.createElementNS('http://www.w3.org/2000/svg','line');
    ln.setAttribute('x1', x1); ln.setAttribute('y1', y1);
    ln.setAttribute('x2', x2); ln.setAttribute('y2', y2);
    ln.setAttribute('stroke', (a%20===0)? 'red' : '#555');
    ln.setAttribute('class','tick');
    g.appendChild(ln);
    if (a%20===0) {
      const tx = Math.cos(rad)*170, ty = Math.sin(rad)*170;
      const t = document.createElementNS('http://www.w3.org/2000/svg','text');
      t.setAttribute('x', tx);
      t.setAttribute('y', ty+4);
      t.setAttribute('text-anchor','middle');
      t.setAttribute('class','label');
      t.setAttribute('fill','red');
      t.textContent = String(a===0? 10 : a); // visually we still place numbers; centered zero label is above
      g.appendChild(t);
    }
    ticks.appendChild(g);
  }

  // State
  let visible = false;
  let mode = 'auto'; // 'auto' tries to bind to dots; 'manual' lets user click 3 points
  let points = { f:null, s:null, m:null };
  let ladderAlt = false;

  function show(){ overlay.hidden = false; visible = true; btn.setAttribute('aria-pressed','true'); }
  function hide(){ overlay.hidden = true; visible = false; btn.setAttribute('aria-pressed','false'); }

  btn.addEventListener('click', () => {
    if (visible) hide();
    else { show(); autoBindOrManual(); }
  });

  function setUIPosition(x, y){
    ui.style.setProperty('--gx', x+'px');
    ui.style.setProperty('--gy', y+'px');
  }

  function setAngles(stationaryAngleDeg, movingAngleDeg){
    // Baseline: rotate entire UI to stationary angle
    ui.style.setProperty('--grot', stationaryAngleDeg + 'deg');
    // Moving arm: rotate relative to stationary
    const rel = movingAngleDeg - stationaryAngleDeg;
    armM.setAttribute('transform', `rotate(${rel})`);
    // Stationary arm stays at 0 within its group
    armS.setAttribute('transform', `rotate(0)`);
    drawLadder(rel);
  }

  function drawLadder(relDeg){
    // Clear
    ladder.textContent = '';
    // Build rungs along moving arm (every 20px)
    const len = 220;
    const step = 20;
    const rad = relDeg * Math.PI/180;
    const cos = Math.cos(rad), sin = Math.sin(rad);
    for (let d=20, i=0; d<=len; d+=step, i++){
      const x = d; const y = 0;
      // rung perpendicular segment ±6px
      const rdx = 0, rdy = 6;
      const color = (i%2===0? (ladderAlt? 'black':'red') : 'black');
      const seg = document.createElementNS('http://www.w3.org/2000/svg','line');
      seg.setAttribute('x1', x); seg.setAttribute('y1', -rdy);
      seg.setAttribute('x2', x); seg.setAttribute('y2', rdy);
      seg.setAttribute('stroke', color);
      seg.setAttribute('stroke-width', 3);
      ladder.appendChild(seg);
    }
  }

  // Toggle ladder alternation when arm head is clicked
  armM.addEventListener('click', (e)=>{
    ladderAlt = !ladderAlt;
    e.stopPropagation();
  });

  // Helpers
  const angleFromTo = (a,b) => Math.atan2(b.y - a.y, b.x - a.x) * 180/Math.PI;

  function updateFromPoints(){
    if (!points.f || !points.s || !points.m) return;
    setUIPosition(points.f.x, points.f.y);
    const aS = angleFromTo(points.f, points.s);
    const aM = angleFromTo(points.f, points.m);
    setAngles(aS, aM);
  }

  // Try auto-binding to existing dots by id or data-role
  function autoBindOrManual(){
    const root = document;
    const fEl = root.querySelector('#dot-fulcrum, [data-role="fulcrum"], [data-dot="fulcrum"]');
    const sEl = root.querySelector('#dot-stationary, [data-role="stationary"], [data-dot="stationary"]');
    const mEl = root.querySelector('#dot-moving, [data-role="moving"], [data-dot="moving"]');
    if (fEl && sEl && mEl) {
      mode = 'auto';
      const rectOf = el => el.getBoundingClientRect();
      const getCenter = el => {
        const r = rectOf(el);
        return { x: r.left + r.width/2 + window.scrollX, y: r.top + r.height/2 + window.scrollY };
      };
      const refresh = () => {
        points.f = getCenter(fEl);
        points.s = getCenter(sEl);
        points.m = getCenter(mEl);
        updateFromPoints();
        if (visible) requestAnimationFrame(refresh);
      };
      refresh();
      return;
    }
    // Manual fallback: click 3 times on canvas/body to set points
    mode = 'manual';
    let step = 0;
    const hint = ['Click fulcrum','Click stationary','Click moving'];
    const onClick = (e) => {
      if (!visible) return;
      const x = e.clientX + window.scrollX, y = e.clientY + window.scrollY;
      if (step===0) points.f = {x,y};
      else if (step===1) points.s = {x,y};
      else points.m = {x,y};
      step++;
      if (step===3){
        updateFromPoints();
        window.removeEventListener('click', onClick, true);
      }
      e.stopPropagation();
      e.preventDefault();
    };
    window.addEventListener('click', onClick, true);
  }

  // Public API for integration if the page wants to drive it directly
  window.GonioOverlay = {
    show, hide,
    setFromPoints: (f,s,m) => { points = {f,s,m}; updateFromPoints(); show(); },
    setFulcrum: (f) => { points.f = f; updateFromPoints(); },
    setStationary: (s) => { points.s = s; updateFromPoints(); },
    setMoving: (m) => { points.m = m; updateFromPoints(); }
  };

  // Optional: wire to your existing buttons (kept non-destructive)
  const measureOn = document.getElementById('measureOn');
  const measureOff = document.getElementById('measureOff');
  const reset = document.getElementById('reset');
  if (measureOn) measureOn.addEventListener('click', ()=>{ overlay.hidden=false; autoBindOrManual(); });
  if (measureOff) measureOff.addEventListener('click', ()=>{ overlay.hidden=true; });
  if (reset) reset.addEventListener('click', ()=>{ overlay.hidden=true; });

})();
</script>

</body>
</html>
