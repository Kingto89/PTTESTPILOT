/* ===== Joint controls (clinical motions) ===== */
// UI hooks
const jointSel   = document.getElementById("jointSel");
const jointAngle = document.getElementById("jointAngle");
const jointZero  = document.getElementById("jointZero");
const jointLog   = document.getElementById("jointLog");

// A tiny DSL to describe each joint:
// - side: 'l' | 'r'
// - boneCandidates: regex list to find the bone
// - axis: 'x' | 'y' | 'z'  (local bone axis for this motion)
// - sign: +1 or -1         (flip if rig’s axis is opposite clinical)
// - range: [min, max] °    (slider range)
// - labelAtZero: for HUD/log context
const JOINTS = {
  knee_flex_l: {
    side:'l', boneCandidates:[/knee/i, /leg.*lower|calf|shin/i, /\b(?:Left)?LowerLeg\b/i, /\b(?:Left)?Up?Leg\b/i],
    axis:'x', sign:-1, range:[-5, 140], labelAtZero:'knee neutral'
  },
  knee_flex_r: {
    side:'r', boneCandidates:[/knee/i, /leg.*lower|calf|shin/i, /\b(?:Right)?LowerLeg\b/i, /\b(?:Right)?Up?Leg\b/i],
    axis:'x', sign:-1, range:[-5, 140], labelAtZero:'knee neutral'
  },
  ankle_dp_l: {
    side:'l', boneCandidates:[/ankle|foot/i, /\bfoot_l\b/i, /\b(?:Left)?Foot\b/i],
    axis:'x', sign:-1, range:[-30, 50],  labelAtZero:'ankle neutral' // - = DF, + = PF
  },
  ankle_dp_r: {
    side:'r', boneCandidates:[/ankle|foot/i, /\bfoot_r\b/i, /\b(?:Right)?Foot\b/i],
    axis:'x', sign:-1, range:[-30, 50],  labelAtZero:'ankle neutral'
  },
  wrist_fe_l: {
    side:'l', boneCandidates:[/wrist|hand/i, /\bhand_l\b/i, /\b(?:Left)?Hand\b/i],
    axis:'x', sign:-1, range:[-80, 80],  labelAtZero:'wrist neutral' // - = flex, + = ext
  },
  wrist_fe_r: {
    side:'r', boneCandidates:[/wrist|hand/i, /\bhand_r\b/i, /\b(?:Right)?Hand\b/i],
    axis:'x', sign:-1, range:[-80, 80],  labelAtZero:'wrist neutral'
  },
  wrist_ru_l: {
    side:'l', boneCandidates:[/wrist|hand/i, /\bhand_l\b/i, /\b(?:Left)?Hand\b/i],
    axis:'z', sign:+1, range:[-30, 30],  labelAtZero:'wrist neutral' // - = radial, + = ulnar
  },
  wrist_ru_r: {
    side:'r', boneCandidates:[/wrist|hand/i, /\bhand_r\b/i, /\b(?:Right)?Hand\b/i],
    axis:'z', sign:-1, range:[-30, 30],  labelAtZero:'wrist neutral' // flip so left/right mirror nicely
  },
  forearm_ps_l: {
    side:'l', boneCandidates:[/forearm|radius|ulna/i, /\blowerarm_l\b/i, /\b(?:Left)?Fore?Arm\b/i],
    axis:'y', sign:+1, range:[-90, 90],  labelAtZero:'neutral (thumb up)' // - = pronation, + = supination
  },
  forearm_ps_r: {
    side:'r', boneCandidates:[/forearm|radius|ulna/i, /\blowerarm_r\b/i, /\b(?:Right)?Fore?Arm\b/i],
    axis:'y', sign:-1, range:[-90, 90],  labelAtZero:'neutral (thumb up)'
  },
};

// cache: which bone each joint resolved to
const JOINT_BIND = new Map(); // id -> { bone, qBind:Quaternion }

function findBoneForJoint(id){
  if (!skeleton) return null;
  const cfg = JOINTS[id]; if (!cfg) return null;
  // prefer side-marked names if present
  const names = skeleton.bones.map(b=>b.name);
  const lower = names.map(n=>n.toLowerCase());
  const preferLeft  = cfg.side === 'l' ? [/left|_l\b|\.l\b/i]  : [];
  const preferRight = cfg.side === 'r' ? [/right|_r\b|\.r\b/i] : [];
  const sideREs = cfg.side === 'l' ? preferLeft : preferRight;

  // scoring: side regex + candidate regex
  for (const cand of cfg.boneCandidates){
    // try side-filtered first
    for (let i=0;i<lower.length;i++){
      if (!sideREs.some(re=>re.test(lower[i]))) continue;
      if (cand.test(lower[i])) return skeleton.bones[i];
    }
    // then any match
    for (let i=0;i<lower.length;i++){
      if (cand.test(lower[i])) return skeleton.bones[i];
    }
  }
  return null;
}

function resolveJoint(id){
  if (!skeleton) return null;
  if (JOINT_BIND.has(id)) return JOINT_BIND.get(id);
  const bone = findBoneForJoint(id);
  if (!bone) { log(`Joint '${id}': bone not found`); return null; }
  const qBind = (initialBoneRot.get(bone) || bone.quaternion.clone()).clone();
  const bind = { bone, qBind };
  JOINT_BIND.set(id, bind);
  log(`Joint '${id}' -> bone '${bone.name}'`);
  return bind;
}

function applyJointAngle(id, deg){
  const cfg = JOINTS[id]; if (!cfg) return;
  const bind = resolveJoint(id); if (!bind) return;
  const { bone, qBind } = bind;

  const rad = THREE.MathUtils.degToRad((deg || 0) * cfg.sign);
  const e = new THREE.Euler(0,0,0,"XYZ");
  if (cfg.axis === 'x') e.set(rad, 0, 0, "XYZ");
  if (cfg.axis === 'y') e.set(0, rad, 0, "XYZ");
  if (cfg.axis === 'z') e.set(0, 0, rad, "XYZ");

  const qDelta = new THREE.Quaternion().setFromEuler(e);
  bone.quaternion.copy(qBind).multiply(qDelta);
}

function syncJointUI(){
  const id = jointSel.value;
  const cfg = JOINTS[id]; if (!cfg) return;
  jointAngle.min  = cfg.range[0];
  jointAngle.max  = cfg.range[1];
  // keep current angle unless out of range
  let v = parseFloat(jointAngle.value) || 0;
  v = Math.min(cfg.range[1], Math.max(cfg.range[0], v));
  jointAngle.value = String(v);
  applyJointAngle(id, v);
}

jointSel.addEventListener("change", syncJointUI);
jointAngle.addEventListener("input", ()=>{
  applyJointAngle(jointSel.value, parseFloat(jointAngle.value)||0);
});
jointZero.addEventListener("click", ()=>{
  jointAngle.value = "0";
  applyJointAngle(jointSel.value, 0);
});
jointLog.addEventListener("click", ()=>{
  const id = jointSel.value;
  const bind = resolveJoint(id);
  if (bind) log(`Joint '${id}' bound to: ${bind.bone.name}`);
});
